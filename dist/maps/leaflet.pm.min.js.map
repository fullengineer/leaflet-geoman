{"version":3,"sources":["leaflet.pm.js","L.PM.js","L.PM.Draw.js","js/L.Controls.js","js/L.PM.Draw.Poly.js","js/L.PM.Edit.Poly.js","js/L.PM.LayerGroup.js"],"names":["L","PM","initialize","initLayerGroup","this","pm","Edit","LayerGroup","addInitHook","initPolygon","Poly","Polygon","initMap","Draw","Map","Class","extend","map","_map","shapes","i","length","shape","getShapes","enableDraw","join","disableDraw","enable","disable","addControls","addButton","Control","PMButton","options","position","_button","setButton","onAdd","container","DomUtil","create","_container","_makeButton","onRemove","button","className","iconUrl","onClick","afterClick","doToggle","toggleStatus","getText","text","getIconUrl","destroy","_update","toggle","e","toggled","onCreate","newButton","addClass","image","setAttribute","DomEvent","addListener","_clicked","disableClickPropagation","removeClass","childNodes","_shape","_enabled","_layerGroup","addTo","_polyline","polyline","color","addLayer","_hintline","dashArray","style","cursor","on","_createPolygonPoint","_syncHintLine","fire","off","removeLayer","enabled","self","drawPolyButton","_drawButton","polyPoints","getLatLngs","lastPolygonPoint","setLatLngs","latlng","first","addLatLng","_createMarker","_finishPolygon","coords","polygonLayer","polygon","toggleEdit","layer","marker","Marker","draggable","icon","divIcon","poly","_poly","_markerGroup","_initMarkers","_initDraggableLayer","dragging","el","_path","_dragging","that","_tempDragCoord","event","bringToFront","eachLayer","setOpacity","_onLayerDrag","_applyPossibleCoordsChanges","_fireEdit","window","setTimeout","deltaLatLng","lat","lng","_markers","currentLatLng","getLatLng","newLatLng","setLatLng","_onMarkerDrag","target","_latlngs","push","k","nextIndex","_createMiddleMarker","index","_origLatLng","_index","_onMarkerDragEnd","_removeMarker","leftM","rightM","_calcMiddleLatLng","middleMarker","setIcon","_middleMarkerNext","_middleMarkerPrev","_addMarker","newM","splice","undefined","redraw","leftMarkerIndex","rightMarkerIndex","_tempPolygon","clearLayers","latlngs","getLayers","_drawTemporaryPolygon","geoJson","setStyle","opacity","fillOpacity","bringToBack","_checkOverlap","layers","changed","resultingGeoJson","toGeoJSON","intersect","turf","console","warn","difference","geometry","type","remove","nextMarkerIndex","prevMarkerIndex","_latlng","markerLatLng","prevMarkerLatLng","nextMarkerLatLng","middleMarkerNextLatLng","middleMarkerPrevLatLng","preventOverlap","edited","latlng1","latlng2","p1","project","p2","unproject","_add","_divideBy","layerGroup","_layers","fireEvent"],"mappings":"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","file":"leaflet.pm.min.js","sourcesContent":["\"use strict\";\n\n/**\n*\n* A Leaflet Plugin For Editing Geometry Layers in Leaflet 1.0\n* by Sumit Kumar (@TweetsOfSumit)\n* Github Repo: https://github.com/codeofsumit/leaflet.pm\n*/\n\nL.PM = L.PM || {\n    initialize: function initialize() {\n\n        var initLayerGroup = function initLayerGroup() {\n            this.pm = new L.PM.Edit.LayerGroup(this);\n        };\n        L.LayerGroup.addInitHook(initLayerGroup);\n\n        var initPolygon = function initPolygon() {\n            this.pm = new L.PM.Edit.Poly(this);\n        };\n        L.Polygon.addInitHook(initPolygon);\n\n        var initMap = function initMap() {\n            this.pm = new L.PM.Draw(this);\n        };\n        L.Map.addInitHook(initMap);\n    },\n    Edit: {}\n};\n\n// initialize leaflet.pm\nL.PM.initialize();\n'use strict';\n\nL.PM.Draw = L.Class.extend({\n\n    initialize: function initialize(map) {\n\n        // save the map\n        this._map = map;\n\n        // define all possible shapes that can be drawn\n        this.shapes = ['Poly'];\n\n        // initiate drawing class for our shapes\n        for (var i = 0; i < this.shapes.length; i++) {\n            var shape = this.shapes[i];\n            this[shape] = new L.PM.Draw[shape](this._map);\n        }\n    },\n    getShapes: function getShapes() {\n        // if somebody wants to know what shapes are available\n        return this.shapes;\n    },\n    enableDraw: function enableDraw(shape) {\n\n        if (!shape) {\n            throw 'Error: Please pass a shape as a parameter. Possible shapes are: ' + this.getShapes().join(',');\n        }\n\n        // disable drawing for all shapes\n        this.disableDraw();\n\n        // enable draw for a shape\n        this[shape].enable();\n    },\n    disableDraw: function disableDraw() {\n\n        // there can only be one drawing mode active at a time on a map\n        // so it doesn't matter which one should be disabled.\n        // just disable all of them\n        for (var i = 0; i < this.shapes.length; i++) {\n            var shape = this.shapes[i];\n            this[shape].disable();\n        }\n    },\n    addControls: function addControls() {\n        // add control buttons for our shapes\n        for (var i = 0; i < this.shapes.length; i++) {\n            var shape = this.shapes[i];\n            this[shape].addButton();\n        }\n    }\n});\n'use strict';\n\nL.Control.PMButton = L.Control.extend({\n    options: {\n        position: 'topleft'\n    },\n    initialize: function initialize(options) {\n        this._button = {};\n        this.setButton(options);\n    },\n\n    onAdd: function onAdd(map) {\n\n        this._map = map;\n        var container = L.DomUtil.create('div', 'leaflet-control-button');\n\n        this._container = container;\n\n        this._makeButton(this._button);\n        return this._container;\n    },\n\n    onRemove: function onRemove(map) {},\n\n    setButton: function setButton(options) {\n        var button = {\n            'className': options.className,\n            'iconUrl': options.iconUrl,\n            'onClick': options.onClick,\n            'afterClick': options.afterClick,\n            'doToggle': options.doToggle,\n            'toggleStatus': options.toggleStatus\n        };\n\n        this._button = button;\n    },\n\n    getText: function getText() {\n        return this._button.text;\n    },\n\n    getIconUrl: function getIconUrl() {\n        return this._button.iconUrl;\n    },\n\n    destroy: function destroy() {\n        this._button = {};\n        this._update();\n    },\n\n    toggle: function toggle(e) {\n        if (typeof e === 'boolean') {\n            this._button.toggleStatus = e;\n        } else {\n            this._button.toggleStatus = !this._button.toggleStatus;\n        }\n    },\n    toggled: function toggled() {\n        return this._button.toggleStatus;\n    },\n    onCreate: function onCreate() {\n        this.toggle(false);\n    },\n    _makeButton: function _makeButton(button) {\n\n        var newButton = L.DomUtil.create('div', 'leaflet-buttons-control-button', this._container);\n        if (button.toggleStatus) L.DomUtil.addClass(newButton, 'active');\n\n        var image = L.DomUtil.create('img', 'control-icon', newButton);\n        if (button.iconUrl) {\n            image.setAttribute('src', button.iconUrl);\n        }\n        if (button.className) {\n            L.DomUtil.addClass(image, button.className);\n        }\n\n        L.DomEvent.addListener(newButton, 'click', button.onClick, this).addListener(newButton, 'click', this._clicked, this).addListener(newButton, 'click', button.afterClick, this);\n\n        L.DomEvent.disableClickPropagation(newButton);\n        return newButton;\n    },\n\n    _clicked: function _clicked() {\n\n        if (this._button.doToggle) {\n\n            if (this._button.toggleStatus) {\n                L.DomUtil.removeClass(this._container.childNodes[0], 'active');\n            } else {\n                L.DomUtil.addClass(this._container.childNodes[0], 'active');\n            }\n            this.toggle();\n        }\n        return;\n    }\n\n});\n\"use strict\";\n'use strict';\n\nL.PM.Draw.Poly = L.PM.Draw.extend({\n\n    initialize: function initialize(map) {\n        this._map = map;\n        this._shape = 'Poly';\n    },\n    enable: function enable(options) {\n        // enable draw mode\n\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the polyLine that'll make up the polygon\n        this._polyline = L.polyline([], { color: 'red' });\n        this._layerGroup.addLayer(this._polyline);\n\n        // this is the hintline from the mouse cursor to the last marker\n        this._hintline = L.polyline([], {\n            color: 'red',\n            dashArray: [5, 5]\n        });\n        this._layerGroup.addLayer(this._hintline);\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._createPolygonPoint, this);\n\n        // sync the hintline on mousemove\n        this._map.on('mousemove', this._syncHintLine, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', { shape: this._shape });\n    },\n    disable: function disable() {\n        // disable draw mode\n\n        // cancel, if drawing mode isn't even enabled\n        if (!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._createPolygonPoint);\n        this._map.off('mousemove', this._syncHintLine);\n\n        // remove layer\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', { shape: this._shape });\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    toggle: function toggle(options) {\n\n        if (this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    addButton: function addButton(map) {\n\n        var self = this;\n\n        var drawPolyButton = {\n            'className': 'icon-polygon',\n            'onClick': function onClick() {},\n            'afterClick': function afterClick(e) {\n                self.toggle();\n            },\n            'doToggle': true,\n            'toggleStatus': false\n        };\n\n        this._drawButton = new L.Control.PMButton(drawPolyButton).addTo(this._map);\n\n        this._map.on('pm:drawstart', function (e) {\n            if (e.shape === self._shape && !self._drawButton.toggled()) {\n                self._drawButton._clicked();\n            }\n        });\n\n        this._map.on('pm:drawend', function (e) {\n            if (e.shape === self._shape && self._drawButton.toggled()) {\n                self._drawButton._clicked();\n            }\n        });\n\n        return this._drawButton;\n    },\n    _syncHintLine: function _syncHintLine(e) {\n\n        var polyPoints = this._polyline.getLatLngs();\n\n        if (polyPoints.length > 0) {\n            var lastPolygonPoint = polyPoints[polyPoints.length - 1];\n            this._hintline.setLatLngs([lastPolygonPoint, e.latlng]);\n        }\n    },\n    _createPolygonPoint: function _createPolygonPoint(e) {\n\n        // is this the first point?\n        var first = this._polyline.getLatLngs().length === 0 ? true : false;\n\n        this._polyline.addLatLng(e.latlng);\n        this._createMarker(e.latlng, first);\n\n        this._hintline.setLatLngs([e.latlng, e.latlng]);\n    },\n    _finishPolygon: function _finishPolygon() {\n\n        var coords = this._polyline.getLatLngs();\n        var polygonLayer = L.polygon(coords).addTo(this._map);\n\n        polygonLayer.pm.toggleEdit();\n\n        this.disable();\n\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polygonLayer\n        });\n    },\n    _createMarker: function _createMarker(latlng, first) {\n\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        this._layerGroup.addLayer(marker);\n\n        if (first) {\n            marker.on('click', this._finishPolygon, this);\n        }\n\n        return marker;\n    }\n});\n'use strict';\n\nL.PM.Edit.Poly = L.Class.extend({\n\n    initialize: function initialize(poly) {\n        this._poly = poly;\n        this._enabled = false;\n    },\n\n    toggleEdit: function toggleEdit(options) {\n        if (!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n\n    enable: function enable(options) {\n\n        var self = this;\n\n        this.options = options;\n\n        if (!this.enabled()) {\n            // change state\n            this._enabled = true;\n\n            // create markers\n            if (!this._markerGroup) {\n                this._markerGroup = new L.LayerGroup();\n\n                // init dragable markers\n                this._initMarkers();\n            }\n\n            // add markerGroup to map\n            this._poly._map.addLayer(this._markerGroup);\n\n            // if polygon gets removed from map, disable edit mode\n            this._poly.on('remove', function () {\n                self.disable();\n            });\n\n            // apply options\n            if (!options) {\n                return;\n            }\n\n            if (this.options.draggable) {\n                this._initDraggableLayer();\n            }\n        }\n    },\n\n    enabled: function enabled() {\n        return this._enabled;\n    },\n\n    disable: function disable() {\n        // prevent disabling if polygon is being dragged\n        if (this.dragging()) {\n            return false;\n        }\n        this._enabled = false;\n        this._poly._map.removeLayer(this._markerGroup);\n\n        // clean up draggable\n        this._poly.off('mousedown');\n        this._poly.off('mouseup');\n\n        // remove draggable class\n        var el = this._poly._path;\n        L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n    },\n\n    dragging: function dragging() {\n        return this._poly._dragging;\n    },\n\n    _initDraggableLayer: function _initDraggableLayer() {\n\n        var that = this;\n\n        // temporary coord variable for delta calculation\n        this._tempDragCoord;\n\n        // add CSS class\n        var el = this._poly._path;\n        L.DomUtil.addClass(el, 'leaflet-pm-draggable');\n\n        this._poly.on('mousedown', function (event) {\n\n            that._tempDragCoord = event.latlng;\n\n            // listen to mousemove on map (instead of polygon), otherwise fast mouse movements stop the drag\n            that._poly._map.on('mousemove', function (e) {\n\n                // set state\n                that._poly._dragging = true;\n                L.DomUtil.addClass(el, 'leaflet-pm-dragging');\n\n                // bring it to front to prevent drag interception\n                that._poly.bringToFront();\n\n                // disbale map drag\n                that._poly._map.dragging.disable();\n\n                // hide markers\n                that._markerGroup.eachLayer(function (marker) {\n                    marker.setOpacity(0);\n                });\n\n                that._onLayerDrag(e);\n            });\n        });\n\n        this._poly.on('mouseup', function (e) {\n\n            // re-enable map drag\n            that._poly._map.dragging.enable();\n\n            // clear up mousemove event\n            that._poly._map.off('mousemove');\n\n            // show markers again\n            that._markerGroup.eachLayer(function (marker) {\n                marker.setOpacity(null);\n            });\n\n            // set new coordinates, more details inside the function\n            that._applyPossibleCoordsChanges();\n\n            // fire edit\n            that._fireEdit();\n\n            // timeout to prevent click event after drag :-/\n            // TODO: do it better as soon as leaflet has a way to do it better :-)\n            window.setTimeout(function () {\n                // set state\n                that._poly._dragging = false;\n                L.DomUtil.removeClass(el, 'leaflet-pm-dragging');\n            }, 10);\n        });\n    },\n\n    _onLayerDrag: function _onLayerDrag(e) {\n\n        var that = this;\n\n        // latLng of mouse event\n        var latlng = e.latlng;\n\n        // delta coords (how far was dragged)\n        var deltaLatLng = {\n            lat: latlng.lat - that._tempDragCoord.lat,\n            lng: latlng.lng - that._tempDragCoord.lng\n        };\n\n        for (var i = 0; i < this._markers.length; i++) {\n\n            // a marker reference\n            var marker = this._markers[i];\n\n            // current coords\n            var currentLatLng = marker.getLatLng();\n\n            // new coords\n            var newLatLng = {\n                lat: currentLatLng.lat + deltaLatLng.lat,\n                lng: currentLatLng.lng + deltaLatLng.lng\n            };\n\n            // set latLng of marker\n            marker.setLatLng(newLatLng);\n\n            // act like the marker was dragged (this will move the polygon etc)\n            this._onMarkerDrag({ target: marker });\n        }\n\n        // save current latlng for next delta calculation\n        this._tempDragCoord = latlng;\n    },\n\n    _initMarkers: function _initMarkers() {\n\n        this._markers = [];\n\n        var coords = this._poly._latlngs[0];\n\n        for (var i = 0; i < coords.length; i++) {\n            var marker = this._createMarker(coords[i], i);\n            this._markers.push(marker);\n        }\n\n        for (var k = 0; k < coords.length; k++) {\n\n            var nextIndex = k + 1 >= coords.length ? 0 : k + 1;\n\n            this._createMiddleMarker(this._markers[k], this._markers[nextIndex]);\n        }\n    },\n\n    // creates initial markers for coordinates\n    _createMarker: function _createMarker(latlng, index) {\n\n        var marker = new L.Marker(latlng, {\n            draggable: true,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        marker._origLatLng = latlng;\n        marker._index = index;\n\n        marker.on('drag', this._onMarkerDrag, this);\n        marker.on('dragend', this._onMarkerDragEnd, this);\n        marker.on('contextmenu', this._removeMarker, this);\n\n        this._markerGroup.addLayer(marker);\n\n        return marker;\n    },\n\n    // creates the middle markes between coordinates\n    _createMiddleMarker: function _createMiddleMarker(leftM, rightM) {\n        var self = this;\n        var latlng = this._calcMiddleLatLng(leftM.getLatLng(), rightM.getLatLng());\n\n        var middleMarker = this._createMarker(latlng);\n        var icon = L.divIcon({ className: 'marker-icon marker-icon-middle' });\n        middleMarker.setIcon(icon);\n\n        // save middle markers to the other markers\n        leftM._middleMarkerNext = middleMarker;\n        rightM._middleMarkerPrev = middleMarker;\n\n        middleMarker.on('click', function () {\n\n            // TODO: move the next two lines inside _addMarker() as soon as\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            // is fixed\n            var icon = L.divIcon({ className: 'marker-icon' });\n            middleMarker.setIcon(icon);\n\n            self._addMarker(middleMarker, leftM, rightM);\n        });\n        middleMarker.on('movestart', function () {\n\n            // TODO: This is a workaround. Remove the moveend listener and callback as soon as this is fixed:\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            middleMarker.on('moveend', function () {\n                var icon = L.divIcon({ className: 'marker-icon' });\n                middleMarker.setIcon(icon);\n\n                middleMarker.off('moveend');\n            });\n\n            self._addMarker(middleMarker, leftM, rightM);\n        });\n    },\n\n    // adds a new marker from a middlemarker\n    _addMarker: function _addMarker(newM, leftM, rightM) {\n\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        var latlng = newM.getLatLng();\n        var coords = this._poly._latlngs[0];\n        var index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        for (var i = 0; i < this._markers.length; i++) {\n            this._markers[i]._index = i;\n        }\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n    },\n\n    _removeMarker: function _removeMarker(e) {\n        var marker = e.target;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if (marker._index !== undefined) {\n\n            // remove polygon coordinate from this marker\n            var coords = this._poly._latlngs[0];\n            var index = marker._index;\n\n            coords.splice(index, 1);\n            this._poly.redraw();\n\n            // remove the marker and the middlemarkers next to it from the map\n            this._markerGroup.removeLayer(marker._middleMarkerPrev);\n            this._markerGroup.removeLayer(marker._middleMarkerNext);\n            this._markerGroup.removeLayer(marker);\n\n            // create the new middlemarker\n            var leftMarkerIndex = index - 1 < 0 ? this._markers.length - 1 : index - 1;\n            var rightMarkerIndex = index + 1 >= this._markers.length ? 0 : index + 1;\n\n            var leftM = this._markers[leftMarkerIndex];\n            var rightM = this._markers[rightMarkerIndex];\n            this._createMiddleMarker(leftM, rightM);\n\n            // remove the marker from the markers array\n            this._markers.splice(index, 1);\n\n            // update the remaining markers indexes\n            for (var i = 0; i < this._markers.length; i++) {\n                this._markers[i]._index = i;\n            }\n\n            // fire edit event\n            this._fireEdit();\n        }\n    },\n\n    _applyPossibleCoordsChanges: function _applyPossibleCoordsChanges() {\n\n        // after the polygon was dragged and changed it's shape because of unallowed intersecting\n        // with another polygon, this function takes the temporarily drawn polygon and applies\n        // it's coordinates to our main polygon\n\n        if (this._tempPolygon) {\n\n            // remove all current markers\n            this._markerGroup.clearLayers();\n\n            // get the new coordinates\n            var latlngs = this._tempPolygon.getLayers()[0].getLatLngs();\n\n            // reshape our main polygon\n            this._poly.setLatLngs(latlngs).redraw();\n\n            // initialize the markers again\n            this._initMarkers();\n        }\n    },\n\n    _drawTemporaryPolygon: function _drawTemporaryPolygon(geoJson) {\n\n        // hide our polygon\n        this._poly.setStyle({ opacity: 0, fillOpacity: 0 });\n\n        // draw a temporary polygon (happens during drag)\n        this._tempPolygon = L.geoJson(geoJson).addTo(this._poly._map).bringToBack();\n    },\n    _checkOverlap: function _checkOverlap() {\n\n        var layers = this._layerGroup.getLayers();\n        var changed = false;\n        var resultingGeoJson = this._poly.toGeoJSON();\n\n        for (var i = 0; i < layers.length; i++) {\n            var layer = layers[i];\n\n            if (layer !== this._poly) {\n\n                var intersect;\n\n                // this needs to be in a try catch block because turf isn't reliable\n                // it throws self-intersection errors even if there are none\n                try {\n                    intersect = turf.intersect(resultingGeoJson, layer.toGeoJSON());\n                } catch (e) {\n                    console.warn('Turf Error :-/');\n                }\n\n                if (intersect) {\n                    resultingGeoJson = turf.difference(resultingGeoJson, layer.toGeoJSON());\n\n                    if (resultingGeoJson.geometry.type !== 'MultiPolygon') {\n                        changed = true;\n                    }\n                }\n            }\n        }\n\n        if (this._tempPolygon) {\n            this._tempPolygon.remove();\n            delete this._tempPolygon;\n        }\n\n        if (changed) {\n            this._drawTemporaryPolygon(resultingGeoJson);\n        } else {\n            this._poly.setStyle({ opacity: 1, fillOpacity: 0.2 });\n        }\n    },\n\n    _onMarkerDrag: function _onMarkerDrag(e) {\n\n        // dragged marker\n        var marker = e.target;\n\n        // the dragged markers neighbors\n        var nextMarkerIndex = marker._index + 1 >= this._markers.length ? 0 : marker._index + 1;\n        var prevMarkerIndex = marker._index - 1 < 0 ? this._markers.length - 1 : marker._index - 1;\n\n        // update marker coordinates which will update polygon coordinates\n        L.extend(marker._origLatLng, marker._latlng);\n        this._poly.redraw();\n\n        // update middle markers on the left and right\n        // be aware that \"next\" and \"prev\" might be interchanged, depending on the geojson array\n        var markerLatLng = marker.getLatLng();\n        var prevMarkerLatLng = this._markers[prevMarkerIndex].getLatLng();\n        var nextMarkerLatLng = this._markers[nextMarkerIndex].getLatLng();\n\n        var middleMarkerNextLatLng = this._calcMiddleLatLng(markerLatLng, nextMarkerLatLng);\n        marker._middleMarkerNext.setLatLng(middleMarkerNextLatLng);\n\n        var middleMarkerPrevLatLng = this._calcMiddleLatLng(markerLatLng, prevMarkerLatLng);\n        marker._middleMarkerPrev.setLatLng(middleMarkerPrevLatLng);\n\n        // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n        if (this.options.preventOverlap) {\n            this._checkOverlap();\n        }\n    },\n\n    _onMarkerDragEnd: function _onMarkerDragEnd(e) {\n\n        var marker = e.target;\n\n        this._applyPossibleCoordsChanges();\n\n        // fire edit event\n        this._fireEdit();\n    },\n\n    _fireEdit: function _fireEdit() {\n        // fire edit event\n        this._poly.edited = true;\n        this._poly.fire('pm:edit');\n    },\n\n    _calcMiddleLatLng: function _calcMiddleLatLng(latlng1, latlng2) {\n        // calculate the middle coordinates between two markers\n        // TODO: put this into a utils.js or something\n\n        var map = this._poly._map,\n            p1 = map.project(latlng1),\n            p2 = map.project(latlng2);\n\n        var latlng = map.unproject(p1._add(p2)._divideBy(2));\n\n        return latlng;\n    }\n\n});\n'use strict';\n\nL.PM.Edit.LayerGroup = L.Class.extend({\n    initialize: function initialize(layerGroup) {\n        var self = this;\n        this._layerGroup = layerGroup;\n        this._layers = layerGroup.getLayers();\n\n        for (var i = 0; i < this._layers.length; i++) {\n            // listen to the edit event of the layers in this group\n            this._layers[i].on('pm:edit', this._fireEdit, this);\n\n            // add reference for the group to each layer inside said group\n            this._layers[i].pm._layerGroup = this._layerGroup;\n        }\n\n        // if a new layer is added to the group, reinitialize\n        this._layerGroup.on('layeradd', function (e) {\n            self.initialize(layerGroup);\n\n            // if editing was already enabled for this group, enable it again\n            // so the new layers are enabled\n            if (e.target.pm.enabled()) {\n                self.enable();\n            }\n        });\n    },\n    _fireEdit: function _fireEdit() {\n        this._layerGroup.fireEvent('pm:edit');\n    },\n    toggleEdit: function toggleEdit(options) {\n\n        for (var i = 0; i < this._layers.length; i++) {\n            this._layers[i].pm.toggleEdit(options);\n        }\n    },\n    enable: function enable(options) {\n        for (var i = 0; i < this._layers.length; i++) {\n            // enable edit for each layer of the group\n            this._layers[i].pm.enable(options);\n        }\n    },\n    disable: function disable() {\n        for (var i = 0; i < this._layers.length; i++) {\n            this._layers[i].pm.disable();\n        }\n    },\n    enabled: function enabled() {\n\n        var enabled = false;\n\n        for (var i = 0; i < this._layers.length; i++) {\n            enabled = this._layers[i].pm.enabled();\n            if (enabled) {\n                break;\n            }\n        }\n\n        return enabled;\n    }\n});","/**\n*\n* A Leaflet Plugin For Editing Geometry Layers in Leaflet 1.0\n* by Sumit Kumar (@TweetsOfSumit)\n* Github Repo: https://github.com/codeofsumit/leaflet.pm\n*/\n\nL.PM = L.PM || {\n    initialize: function() {\n\n        var initLayerGroup = function() {\n            this.pm = new L.PM.Edit.LayerGroup(this);\n        };\n        L.LayerGroup.addInitHook(initLayerGroup);\n\n\n        var initPolygon = function() {\n            this.pm = new L.PM.Edit.Poly(this);\n        };\n        L.Polygon.addInitHook(initPolygon);\n\n\n        var initMap = function() {\n            this.pm = new L.PM.Draw(this);\n        };\n        L.Map.addInitHook(initMap);\n\n    },\n    Edit: {}\n};\n\n// initialize leaflet.pm\nL.PM.initialize();\n","L.PM.Draw = L.Class.extend({\n\n    initialize: function(map) {\n\n        // save the map\n        this._map = map;\n\n        // define all possible shapes that can be drawn\n        this.shapes = ['Poly'];\n\n        // initiate drawing class for our shapes\n        for(var i=0; i<this.shapes.length; i++) {\n            var shape = this.shapes[i];\n            this[shape] = new L.PM.Draw[shape](this._map);\n        }\n\n    },\n    getShapes: function() {\n        // if somebody wants to know what shapes are available\n        return this.shapes;\n    },\n    enableDraw: function(shape) {\n\n        if(!shape) {\n            throw 'Error: Please pass a shape as a parameter. Possible shapes are: ' + this.getShapes().join(',');\n        }\n\n        // disable drawing for all shapes\n        this.disableDraw();\n\n        // enable draw for a shape\n        this[shape].enable();\n\n    },\n    disableDraw: function() {\n\n        // there can only be one drawing mode active at a time on a map\n        // so it doesn't matter which one should be disabled.\n        // just disable all of them\n        for(var i=0; i<this.shapes.length; i++) {\n            var shape = this.shapes[i];\n            this[shape].disable();\n        }\n\n    },\n    addControls: function() {\n        // add control buttons for our shapes\n        for(var i=0; i<this.shapes.length; i++) {\n            var shape = this.shapes[i];\n            this[shape].addButton();\n        }\n    }\n});\n","L.Control.PMButton = L.Control.extend({\n    options: {\n        position: 'topleft'\n    },\n    initialize: function (options) {\n        this._button = {};\n        this.setButton(options);\n    },\n\n    onAdd: function (map) {\n\n        this._map = map;\n        var container = L.DomUtil.create('div', 'leaflet-control-button');\n\n        this._container = container;\n\n        this._makeButton(this._button);\n        return this._container;\n    },\n\n    onRemove: function (map) {\n    },\n\n    setButton: function (options) {\n        var button = {\n            'className': options.className,\n            'iconUrl': options.iconUrl,\n            'onClick': options.onClick,\n            'afterClick': options.afterClick,\n            'doToggle': options.doToggle,\n            'toggleStatus': options.toggleStatus\n        };\n\n        this._button = button;\n    },\n\n    getText: function () {\n        return this._button.text;\n    },\n\n    getIconUrl: function () {\n        return this._button.iconUrl;\n    },\n\n    destroy: function () {\n        this._button = {};\n        this._update();\n    },\n\n    toggle: function (e) {\n        if(typeof e === 'boolean'){\n            this._button.toggleStatus = e;\n        }\n        else{\n            this._button.toggleStatus = !this._button.toggleStatus;\n        }\n    },\n    toggled: function () {\n        return this._button.toggleStatus;\n    },\n    onCreate: function() {\n        this.toggle(false);\n    },\n    _makeButton: function(button) {\n\n        var newButton = L.DomUtil.create('div', 'leaflet-buttons-control-button', this._container);\n        if(button.toggleStatus)\n            L.DomUtil.addClass(newButton,'active');\n\n        var image = L.DomUtil.create('img', 'control-icon', newButton);\n        if (button.iconUrl) {\n            image.setAttribute('src', button.iconUrl);\n        }\n        if (button.className) {\n            L.DomUtil.addClass(image, button.className);\n        }\n\n        L.DomEvent\n            .addListener(newButton, 'click', button.onClick, this)\n            .addListener(newButton, 'click', this._clicked, this)\n            .addListener(newButton, 'click', button.afterClick, this);\n\n        L.DomEvent.disableClickPropagation(newButton);\n        return newButton;\n\n    },\n\n    _clicked: function () {\n\n        if(this._button.doToggle){\n\n            if(this._button.toggleStatus) {\n                L.DomUtil.removeClass(this._container.childNodes[0],'active');\n            }\n            else {\n                L.DomUtil.addClass(this._container.childNodes[0],'active');\n            }\n            this.toggle();\n        }\n        return;\n    }\n\n});\n","L.PM.Draw.Poly = L.PM.Draw.extend({\n\n    initialize: function(map) {\n        this._map = map;\n        this._shape = 'Poly';\n    },\n    enable: function(options) {\n        // enable draw mode\n\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the polyLine that'll make up the polygon\n        this._polyline = L.polyline([], {color: 'red'});\n        this._layerGroup.addLayer(this._polyline);\n\n        // this is the hintline from the mouse cursor to the last marker\n        this._hintline = L.polyline([], {\n            color: 'red',\n            dashArray: [5, 5]\n        });\n        this._layerGroup.addLayer(this._hintline);\n\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._createPolygonPoint, this);\n\n        // sync the hintline on mousemove\n        this._map.on('mousemove', this._syncHintLine, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', {shape: this._shape});\n\n    },\n    disable: function() {\n        // disable draw mode\n\n        // cancel, if drawing mode isn't even enabled\n        if(!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._createPolygonPoint);\n        this._map.off('mousemove', this._syncHintLine);\n\n        // remove layer\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', {shape: this._shape});\n\n    },\n    enabled: function() {\n        return this._enabled;\n    },\n    toggle: function(options) {\n\n        if(this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n\n    },\n    addButton: function(map) {\n\n        var self = this;\n\n        var drawPolyButton = {\n              'className': 'icon-polygon',\n              'onClick': function() {\n\n              },\n              'afterClick': function(e) {\n                  self.toggle();\n              },\n              'doToggle': true,\n              'toggleStatus': false\n        };\n\n        this._drawButton = new L.Control.PMButton(drawPolyButton).addTo(this._map);\n\n        this._map.on('pm:drawstart', function(e) {\n            if(e.shape === self._shape && !self._drawButton.toggled()) {\n                self._drawButton._clicked();\n            }\n        });\n\n        this._map.on('pm:drawend', function(e) {\n            if(e.shape === self._shape && self._drawButton.toggled()) {\n                self._drawButton._clicked();\n            }\n        });\n\n        return this._drawButton;\n\n    },\n    _syncHintLine: function(e) {\n\n        var polyPoints = this._polyline.getLatLngs();\n\n        if(polyPoints.length > 0) {\n            var lastPolygonPoint = polyPoints[polyPoints.length - 1];\n            this._hintline.setLatLngs([lastPolygonPoint, e.latlng]);\n        }\n\n\n\n    },\n    _createPolygonPoint: function(e) {\n\n        // is this the first point?\n        var first = this._polyline.getLatLngs().length === 0 ? true : false;\n\n        this._polyline.addLatLng(e.latlng);\n        this._createMarker(e.latlng, first);\n\n\n        this._hintline.setLatLngs([e.latlng, e.latlng]);\n\n    },\n    _finishPolygon: function() {\n\n        var coords = this._polyline.getLatLngs();\n        var polygonLayer = L.polygon(coords).addTo(this._map);\n\n        polygonLayer.pm.toggleEdit();\n\n        this.disable();\n\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polygonLayer\n        });\n    },\n    _createMarker: function(latlng, first) {\n\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({className: 'marker-icon'})\n        });\n\n        this._layerGroup.addLayer(marker);\n\n        if(first) {\n            marker.on('click', this._finishPolygon, this);\n        }\n\n        return marker;\n\n    },\n});\n","L.PM.Edit.Poly = L.Class.extend({\n\n    initialize: function(poly) {\n        this._poly = poly;\n        this._enabled = false;\n    },\n\n    toggleEdit: function(options) {\n        if(!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n\n    enable: function(options) {\n\n        var self = this;\n\n        this.options = options;\n\n        if(!this.enabled()) {\n            // change state\n            this._enabled = true;\n\n            // create markers\n            if(!this._markerGroup) {\n                this._markerGroup = new L.LayerGroup();\n\n                // init dragable markers\n                this._initMarkers();\n            }\n\n            // add markerGroup to map\n            this._poly._map.addLayer(this._markerGroup);\n\n            // if polygon gets removed from map, disable edit mode\n            this._poly.on('remove', function() {\n                self.disable();\n            });\n\n            // apply options\n            if(!options) {\n                return;\n            }\n\n            if(this.options.draggable) {\n                this._initDraggableLayer();\n            }\n        }\n\n    },\n\n    enabled: function() {\n        return this._enabled;\n    },\n\n    disable: function() {\n        // prevent disabling if polygon is being dragged\n        if(this.dragging()) {\n            return false;\n        }\n        this._enabled = false;\n        this._poly._map.removeLayer(this._markerGroup);\n\n        // clean up draggable\n        this._poly.off('mousedown');\n        this._poly.off('mouseup');\n\n        // remove draggable class\n        var el = this._poly._path;\n        L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n    },\n\n    dragging: function() {\n        return this._poly._dragging;\n    },\n\n    _initDraggableLayer: function() {\n\n        var that = this;\n\n        // temporary coord variable for delta calculation\n        this._tempDragCoord;\n\n        // add CSS class\n        var el = this._poly._path;\n        L.DomUtil.addClass(el, 'leaflet-pm-draggable');\n\n        this._poly.on('mousedown', function(event) {\n\n            that._tempDragCoord = event.latlng;\n\n            // listen to mousemove on map (instead of polygon), otherwise fast mouse movements stop the drag\n            that._poly._map.on('mousemove', function(e) {\n\n                // set state\n                that._poly._dragging = true;\n                L.DomUtil.addClass(el, 'leaflet-pm-dragging');\n\n                // bring it to front to prevent drag interception\n                that._poly.bringToFront();\n\n                // disbale map drag\n                that._poly._map.dragging.disable();\n\n                // hide markers\n                that._markerGroup.eachLayer(function(marker) {\n                    marker.setOpacity(0);\n                });\n\n                that._onLayerDrag(e);\n            });\n\n        });\n\n        this._poly.on('mouseup', function(e) {\n\n            // re-enable map drag\n            that._poly._map.dragging.enable();\n\n            // clear up mousemove event\n            that._poly._map.off('mousemove');\n\n            // show markers again\n            that._markerGroup.eachLayer(function(marker) {\n                marker.setOpacity(null);\n            });\n\n            // set new coordinates, more details inside the function\n            that._applyPossibleCoordsChanges();\n\n            // fire edit\n            that._fireEdit();\n\n            // timeout to prevent click event after drag :-/\n            // TODO: do it better as soon as leaflet has a way to do it better :-)\n            window.setTimeout(function() {\n                // set state\n                that._poly._dragging = false;\n                L.DomUtil.removeClass(el, 'leaflet-pm-dragging');\n            }, 10)\n\n\n        });\n\n    },\n\n    _onLayerDrag: function(e) {\n\n        var that = this;\n\n        // latLng of mouse event\n        var latlng = e.latlng;\n\n        // delta coords (how far was dragged)\n        var deltaLatLng = {\n            lat: latlng.lat - that._tempDragCoord.lat,\n            lng: latlng.lng - that._tempDragCoord.lng\n        };\n\n        for(var i = 0; i < this._markers.length; i++) {\n\n            // a marker reference\n            var marker = this._markers[i];\n\n            // current coords\n            var currentLatLng = marker.getLatLng();\n\n            // new coords\n            var newLatLng = {\n                lat: currentLatLng.lat + deltaLatLng.lat,\n                lng: currentLatLng.lng + deltaLatLng.lng\n            }\n\n            // set latLng of marker\n            marker.setLatLng(newLatLng);\n\n            // act like the marker was dragged (this will move the polygon etc)\n            this._onMarkerDrag({target: marker});\n\n        }\n\n        // save current latlng for next delta calculation\n        this._tempDragCoord = latlng;\n\n\n    },\n\n    _initMarkers: function() {\n\n        this._markers = [];\n\n        var coords = this._poly._latlngs[0];\n\n        for(var i = 0; i < coords.length; i++) {\n            var marker = this._createMarker(coords[i], i);\n            this._markers.push(marker);\n        }\n\n        for(var k = 0; k < coords.length; k++) {\n\n            var nextIndex = k+1 >= coords.length ? 0 : k+1;\n\n            this._createMiddleMarker(\n                this._markers[k], this._markers[nextIndex]\n            );\n        }\n\n    },\n\n    // creates initial markers for coordinates\n    _createMarker: function(latlng, index) {\n\n        var marker = new L.Marker(latlng, {\n            draggable: true,\n            icon: L.divIcon({className: 'marker-icon'})\n        });\n\n        marker._origLatLng = latlng;\n        marker._index = index;\n\n        marker.on('drag', this._onMarkerDrag, this);\n        marker.on('dragend', this._onMarkerDragEnd, this);\n        marker.on('contextmenu', this._removeMarker, this);\n\n        this._markerGroup.addLayer(marker);\n\n        return marker;\n\n    },\n\n    // creates the middle markes between coordinates\n    _createMiddleMarker: function(leftM, rightM) {\n        var self = this;\n        var latlng = this._calcMiddleLatLng(leftM.getLatLng(), rightM.getLatLng());\n\n        var middleMarker = this._createMarker(latlng);\n        var icon = L.divIcon({className: 'marker-icon marker-icon-middle'})\n        middleMarker.setIcon(icon);\n\n        // save middle markers to the other markers\n        leftM._middleMarkerNext = middleMarker;\n        rightM._middleMarkerPrev = middleMarker;\n\n        middleMarker.on('click', function() {\n\n            // TODO: move the next two lines inside _addMarker() as soon as\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            // is fixed\n            var icon = L.divIcon({className: 'marker-icon'});\n            middleMarker.setIcon(icon);\n\n            self._addMarker(middleMarker, leftM, rightM);\n        });\n        middleMarker.on('movestart', function() {\n\n            // TODO: This is a workaround. Remove the moveend listener and callback as soon as this is fixed:\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            middleMarker.on('moveend', function() {\n                var icon = L.divIcon({className: 'marker-icon'});\n                middleMarker.setIcon(icon);\n\n                middleMarker.off('moveend');\n            });\n\n            self._addMarker(middleMarker, leftM, rightM);\n        });\n\n\n    },\n\n    // adds a new marker from a middlemarker\n    _addMarker: function(newM, leftM, rightM) {\n\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        var latlng = newM.getLatLng();\n        var coords = this._poly._latlngs[0];\n        var index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        for(var i=0;i<this._markers.length;i++) {\n            this._markers[i]._index = i;\n        }\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n\n\n    },\n\n    _removeMarker: function(e) {\n        var marker = e.target;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if(marker._index !== undefined) {\n\n            // remove polygon coordinate from this marker\n            var coords = this._poly._latlngs[0];\n            var index = marker._index;\n\n            coords.splice(index, 1);\n            this._poly.redraw();\n\n            // remove the marker and the middlemarkers next to it from the map\n            this._markerGroup.removeLayer(marker._middleMarkerPrev);\n            this._markerGroup.removeLayer(marker._middleMarkerNext);\n            this._markerGroup.removeLayer(marker);\n\n\n            // create the new middlemarker\n            var leftMarkerIndex = index - 1 < 0 ? this._markers.length - 1 : index - 1;\n            var rightMarkerIndex = index + 1 >= this._markers.length ? 0 : index + 1;\n\n            var leftM = this._markers[leftMarkerIndex];\n            var rightM = this._markers[rightMarkerIndex];\n            this._createMiddleMarker(leftM, rightM);\n\n\n            // remove the marker from the markers array\n            this._markers.splice(index, 1);\n\n            // update the remaining markers indexes\n            for(var i=0;i<this._markers.length;i++) {\n                this._markers[i]._index = i;\n            }\n\n            // fire edit event\n            this._fireEdit();\n\n        }\n\n\n    },\n\n    _applyPossibleCoordsChanges: function() {\n\n        // after the polygon was dragged and changed it's shape because of unallowed intersecting\n        // with another polygon, this function takes the temporarily drawn polygon and applies\n        // it's coordinates to our main polygon\n\n        if(this._tempPolygon) {\n\n            // remove all current markers\n            this._markerGroup.clearLayers();\n\n            // get the new coordinates\n            var latlngs = this._tempPolygon.getLayers()[0].getLatLngs();\n\n            // reshape our main polygon\n            this._poly.setLatLngs(latlngs).redraw();\n\n            // initialize the markers again\n            this._initMarkers();\n        }\n\n    },\n\n    _drawTemporaryPolygon: function(geoJson) {\n\n        // hide our polygon\n        this._poly.setStyle({opacity: 0, fillOpacity: 0});\n\n        // draw a temporary polygon (happens during drag)\n        this._tempPolygon = L.geoJson(geoJson).addTo(this._poly._map).bringToBack();\n\n    },\n    _checkOverlap: function() {\n\n        var layers = this._layerGroup.getLayers();\n        var changed = false;\n        var resultingGeoJson = this._poly.toGeoJSON();\n\n        for(var i=0; i<layers.length; i++) {\n            var layer = layers[i];\n\n            if(layer !== this._poly) {\n\n                var intersect;\n\n                // this needs to be in a try catch block because turf isn't reliable\n                // it throws self-intersection errors even if there are none\n                try {\n                    intersect = turf.intersect(resultingGeoJson, layer.toGeoJSON());\n                } catch(e) {\n                    console.warn('Turf Error :-/');\n                }\n\n                if(intersect) {\n                    resultingGeoJson = turf.difference(resultingGeoJson, layer.toGeoJSON());\n\n                    if(resultingGeoJson.geometry.type !== 'MultiPolygon') {\n                        changed = true;\n                    }\n                }\n\n            }\n        }\n\n        if(this._tempPolygon) {\n            this._tempPolygon.remove();\n            delete this._tempPolygon;\n        }\n\n        if(changed) {\n            this._drawTemporaryPolygon(resultingGeoJson);\n        } else {\n            this._poly.setStyle({opacity: 1, fillOpacity: 0.2});\n        }\n\n\n\n    },\n\n    _onMarkerDrag: function(e) {\n\n        // dragged marker\n        var marker = e.target;\n\n        // the dragged markers neighbors\n        var nextMarkerIndex = marker._index + 1 >= this._markers.length ? 0 : marker._index + 1;\n        var prevMarkerIndex = marker._index - 1 < 0 ? this._markers.length - 1 : marker._index - 1;\n\n        // update marker coordinates which will update polygon coordinates\n        L.extend(marker._origLatLng, marker._latlng);\n        this._poly.redraw();\n\n        // update middle markers on the left and right\n        // be aware that \"next\" and \"prev\" might be interchanged, depending on the geojson array\n        var markerLatLng = marker.getLatLng();\n        var prevMarkerLatLng = this._markers[prevMarkerIndex].getLatLng();\n        var nextMarkerLatLng = this._markers[nextMarkerIndex].getLatLng();\n\n        var middleMarkerNextLatLng = this._calcMiddleLatLng(markerLatLng, nextMarkerLatLng);\n        marker._middleMarkerNext.setLatLng(middleMarkerNextLatLng);\n\n        var middleMarkerPrevLatLng = this._calcMiddleLatLng(markerLatLng, prevMarkerLatLng);\n        marker._middleMarkerPrev.setLatLng(middleMarkerPrevLatLng);\n\n\n        // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n        if(this.options.preventOverlap) {\n            this._checkOverlap();\n        }\n\n    },\n\n    _onMarkerDragEnd: function(e) {\n\n        var marker = e.target;\n\n        this._applyPossibleCoordsChanges();\n\n        // fire edit event\n        this._fireEdit();\n\n    },\n\n    _fireEdit: function () {\n        // fire edit event\n        this._poly.edited = true;\n        this._poly.fire('pm:edit');\n    },\n\n    _calcMiddleLatLng: function(latlng1, latlng2) {\n        // calculate the middle coordinates between two markers\n        // TODO: put this into a utils.js or something\n\n        var map = this._poly._map,\n            p1 = map.project(latlng1),\n            p2 = map.project(latlng2);\n\n        var latlng = map.unproject(p1._add(p2)._divideBy(2));\n\n        return latlng;\n    }\n\n});\n","\nL.PM.Edit.LayerGroup = L.Class.extend({\n    initialize: function(layerGroup) {\n        var self = this;\n        this._layerGroup = layerGroup;\n        this._layers = layerGroup.getLayers();\n\n        for(var i=0; i<this._layers.length; i++) {\n            // listen to the edit event of the layers in this group\n            this._layers[i].on('pm:edit', this._fireEdit, this);\n\n            // add reference for the group to each layer inside said group\n            this._layers[i].pm._layerGroup = this._layerGroup;\n        }\n\n        // if a new layer is added to the group, reinitialize\n        this._layerGroup.on('layeradd', function(e) {\n            self.initialize(layerGroup);\n\n            // if editing was already enabled for this group, enable it again\n            // so the new layers are enabled\n            if(e.target.pm.enabled()) {\n                self.enable();\n            }\n        });\n    },\n    _fireEdit: function() {\n        this._layerGroup.fireEvent('pm:edit');\n    },\n    toggleEdit: function(options) {\n\n        for(var i=0; i<this._layers.length; i++) {\n            this._layers[i].pm.toggleEdit(options);\n        }\n    },\n    enable: function(options) {\n        for(var i=0; i<this._layers.length; i++) {\n            // enable edit for each layer of the group\n            this._layers[i].pm.enable(options);\n        }\n    },\n    disable: function() {\n        for(var i=0; i<this._layers.length; i++) {\n            this._layers[i].pm.disable();\n        }\n    },\n    enabled: function() {\n\n        var enabled = false;\n\n        for(var i=0; i<this._layers.length; i++) {\n            enabled = this._layers[i].pm.enabled();\n            if(enabled) {\n                break;\n            }\n        }\n\n        return enabled;\n    }\n});\n"],"sourceRoot":"/source/"}