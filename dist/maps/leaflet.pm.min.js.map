{"version":3,"sources":["leaflet.pm.js","Drag.js","Overlap.js","Snapping.js","L.PM.js","L.PM.Map.js","L.PM.Draw.js","L.PM.Edit.js","Draw/L.PM.Draw.Poly.js","Edit/L.PM.Edit.LayerGroup.js","Edit/L.PM.Edit.Poly.js","Toolbar/L.Controls.js","Toolbar/L.PM.Toolbar.js"],"names":["DragMixin","_initDraggableLayer","_this","this","_tempDragCoord","el","_poly","_path","L","DomUtil","addClass","onMouseUp","e","_map","dragging","enable","off","_initMarkers","window","setTimeout","_dragging","removeClass","fire","_fireEdit","onMouseMove","bringToFront","disable","_markerGroup","clearLayers","_onLayerDrag","on","latlng","deltaLatLng","lat","lng","coords","_latlngs","newLatLngs","map","currentLatLng","setLatLngs","redraw","OverlapMixin","_applyPossibleCoordsChanges","_tempPolygon","latlngs","getLayers","getLatLngs","_drawTemporaryPolygon","geoJson","setStyle","opacity","fillOpacity","addTo","bringToBack","_handleOverlap","mainPoly","layers","_layerGroup","changed","resultingGeoJson","toGeoJSON","filter","layer","Object","is","intersect","turf","console","warn","difference","geometry","type","remove","SnapMixin","_initSnappableMarkers","_markers","forEach","marker","_handleSnapping","_cleanupSnapping","log","_snapList","debugIndicatorLines","line","undefined","_createSnapList","target","_calcClosestLayer","getLatLng","closestLatLng","distance","minDistance","setLatLng","_onMarkerDrag","_this2","eachLayer","Polyline","push","polyline","color","_this3","closestPolygon","closestDistance","index","closestLatLngOfPoly","_getClosestLayerLatlng","P","latLngToLayerPoint","C","distanceTo","shortestDistance","closestSegment","point","nextIndex","length","A","B","LineUtil","pointToSegmentDistance","closestPoint","closestPointOnSegment","layerPointToLatLng","PM","initialize","initLayerGroup","pm","Edit","LayerGroup","addInitHook","initPolygon","Poly","Polygon","initMap","Map","Class","extend","Draw","Toolbar","addControls","options","enableDraw","shape","arguments","disableDraw","removeLayer","_layers","toggleRemoval","enabled","shapes","getShapes","join","addButton","includes","_shape","registerButton","toolbarButtonName","_enabled","_polyline","addLayer","_hintline","dashArray","_container","style","cursor","_createPolygonPoint","_syncHintLine","toggleButton","toggle","polyPoints","lastPolygonPoint","first","addLatLng","_createMarker","_finishPolygon","polygonLayer","polygon","toggleEdit","Marker","draggable","icon","divIcon","className","layerGroup","availableEvents","event","_fireEvent","getOptions","fireEvent","_options","find","poly","k","_createMiddleMarker","snap","_origLatLng","_index","_onMarkerDragEnd","_removeMarker","leftM","rightM","_calcMiddleLatLng","middleMarker","setIcon","_middleMarkerNext","_middleMarkerPrev","_addMarker","newM","splice","i","leftMarkerIndex","rightMarkerIndex","nextMarkerIndex","prevMarkerIndex","_latlng","markerLatLng","prevMarkerLatLng","nextMarkerLatLng","middleMarkerNextLatLng","middleMarkerPrevLatLng","edited","latlng1","latlng2","p1","project","p2","unproject","_add","_divideBy","Control","PMButton","position","_button","setButton","onAdd","container","buttonsDomNode","_makeButton","appendChild","onRemove","button","iconUrl","onClick","afterClick","doToggle","toggleStatus","disableOtherButtons","getText","text","getIconUrl","destroy","_update","_applyStyleClasses","toggled","onCreate","_triggerClick","_clicked","newButton","create","image","setAttribute","DomEvent","addListener","triggerClickOnToggledButtons","disableClickPropagation","drawPolygon","editPolygon","dragPolygon","deleteLayer","buttons","_defineButtons","getButtons","Util","setOptions","_showHideButtons","_addButton","name","exceptThisButton","status","deleteButton","drawPolyButton","editButton","dragButton","btn"],"mappings":"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","file":"leaflet.pm.min.js","sourcesContent":["'use strict';\n\nvar DragMixin = {\n    _initDraggableLayer: function _initDraggableLayer() {\n        var _this = this;\n\n        // temporary coord variable for delta calculation\n        this._tempDragCoord;\n\n        // add CSS class\n        var el = this._poly._path;\n        L.DomUtil.addClass(el, 'leaflet-pm-draggable');\n\n        var onMouseUp = function onMouseUp(e) {\n\n            // re-enable map drag\n            _this._poly._map.dragging.enable();\n\n            // clear up mousemove event\n            _this._poly._map.off('mousemove');\n\n            // clear up mouseup event\n            _this._poly.off('mouseup');\n\n            // show markers again\n            _this._initMarkers();\n\n            // timeout to prevent click event after drag :-/\n            // TODO: do it better as soon as leaflet has a way to do it better :-)\n            window.setTimeout(function () {\n                // set state\n                _this._dragging = false;\n                L.DomUtil.removeClass(el, 'leaflet-pm-dragging');\n\n                // fire pm:dragend event\n                _this._poly.fire('pm:dragend');\n\n                // fire edit\n                _this._fireEdit();\n            }, 10);\n        };\n\n        var onMouseMove = function onMouseMove(e) {\n\n            if (!_this._dragging) {\n\n                // set state\n                _this._dragging = true;\n                L.DomUtil.addClass(el, 'leaflet-pm-dragging');\n\n                // bring it to front to prevent drag interception\n                _this._poly.bringToFront();\n\n                // disbale map drag\n                _this._poly._map.dragging.disable();\n\n                // hide markers\n                _this._markerGroup.clearLayers();\n\n                // fire pm:dragstart event\n                _this._poly.fire('pm:dragstart');\n            }\n\n            _this._onLayerDrag(e);\n        };\n\n        this._poly.on('mousedown', function (e) {\n\n            // save for delta calculation\n            _this._tempDragCoord = e.latlng;\n\n            _this._poly.on('mouseup', onMouseUp);\n\n            // listen to mousemove on map (instead of polygon),\n            // otherwise fast mouse movements stop the drag\n            _this._poly._map.on('mousemove', onMouseMove);\n        });\n    },\n    dragging: function dragging() {\n        return this._dragging;\n    },\n\n    _onLayerDrag: function _onLayerDrag(e) {\n\n        // latLng of mouse event\n        var latlng = e.latlng;\n\n        // delta coords (how far was dragged)\n        var deltaLatLng = {\n            lat: latlng.lat - this._tempDragCoord.lat,\n            lng: latlng.lng - this._tempDragCoord.lng\n        };\n\n        // create the new coordinates array\n        var coords = this._poly._latlngs[0];\n        var newLatLngs = coords.map(function (currentLatLng) {\n            return {\n                lat: currentLatLng.lat + deltaLatLng.lat,\n                lng: currentLatLng.lng + deltaLatLng.lng\n            };\n        });\n\n        // set new coordinates and redraw\n        this._poly.setLatLngs(newLatLngs).redraw();\n\n        // save current latlng for next delta calculation\n        this._tempDragCoord = latlng;\n\n        // fire pm:dragstart event\n        this._poly.fire('pm:drag');\n    }\n};\n'use strict';\n\n// this isn't included anymore but if you want to re-enable it:\n// 1. include this mixing inside L.PM.Edit.js\n// 2. include the turf.js dependency in your project before leaflet.pm\n// 3. uncomment all code inside L.PM.Edit.Poly that has an if-check on options.preventOverlap\n// 4. pass the option preventOverlap to the enable() function on your layer\nvar OverlapMixin = {\n\n    _applyPossibleCoordsChanges: function _applyPossibleCoordsChanges() {\n\n        // after the polygon was dragged and changed it's shape because of unallowed intersecting\n        // with another polygon, this function takes the temporarily drawn polygon (during drag) and applies\n        // it's coordinates to our main polygon\n\n        if (this._tempPolygon) {\n\n            // get the new coordinates\n            var latlngs = this._tempPolygon.getLayers()[0].getLatLngs();\n\n            // reshape our main polygon\n            this._poly.setLatLngs(latlngs).redraw();\n\n            // initialize the markers again\n            this._initMarkers();\n        }\n    },\n\n    _drawTemporaryPolygon: function _drawTemporaryPolygon(geoJson) {\n\n        // hide our polygon\n        this._poly.setStyle({ opacity: 0, fillOpacity: 0 });\n\n        // draw a temporary polygon (happens during drag & intersection)\n        this._tempPolygon = L.geoJson(geoJson).addTo(this._poly._map).bringToBack();\n    },\n\n    _handleOverlap: function _handleOverlap() {\n\n        var mainPoly = this._poly;\n        var layers = this._layerGroup.getLayers();\n        var changed = false;\n        var resultingGeoJson = this._poly.toGeoJSON();\n\n        layers.filter(function (layer) {\n            return !Object.is(layer, mainPoly);\n        }).map(function (layer) {\n\n            var intersect = void 0;\n\n            // this needs to be in a try catch block because turf isn't reliable\n            // it throws self-intersection errors even if there are none\n            try {\n                intersect = turf.intersect(resultingGeoJson, layer.toGeoJSON());\n            } catch (e) {\n                console.warn('Turf Error.');\n            }\n\n            if (intersect) {\n                resultingGeoJson = turf.difference(resultingGeoJson, layer.toGeoJSON());\n\n                // if the resulting polygon is a MultiPolygon, don't handle it.\n                if (resultingGeoJson.geometry.type !== 'MultiPolygon') {\n                    changed = true;\n                }\n            }\n        });\n\n        if (this._tempPolygon) {\n            this._tempPolygon.remove();\n            delete this._tempPolygon;\n        }\n\n        if (changed) {\n            this._drawTemporaryPolygon(resultingGeoJson);\n        } else {\n            this._poly.setStyle({ opacity: 1, fillOpacity: 0.2 });\n        }\n    }\n};\n'use strict';\n\nvar SnapMixin = {\n    _initSnappableMarkers: function _initSnappableMarkers() {\n        var _this = this;\n\n        this._markers.forEach(function (marker) {\n\n            marker.off('drag', _this._handleSnapping, _this);\n            marker.on('drag', _this._handleSnapping, _this);\n\n            marker.off('dragend', _this._cleanupSnapping, _this);\n            marker.on('dragend', _this._cleanupSnapping, _this);\n        });\n    },\n    _cleanupSnapping: function _cleanupSnapping(e) {\n        console.log('drag end');\n\n        delete this._snapList;\n\n        this.debugIndicatorLines.forEach(function (line) {\n            line.remove();\n        });\n    },\n    _handleSnapping: function _handleSnapping(e) {\n\n        if (this._snapList === undefined) {\n            this._createSnapList(e);\n        }\n\n        var marker = e.target;\n\n        // get the closest layer, it's closest latlng and the distance\n\n        var _calcClosestLayer = this._calcClosestLayer(marker.getLatLng(), this._snapList);\n\n        var layer = _calcClosestLayer.layer;\n        var closestLatLng = _calcClosestLayer.closestLatLng;\n        var distance = _calcClosestLayer.distance;\n\n        // minimal distance before marker snaps (in pixels)\n\n        var minDistance = 30;\n\n        if (distance < minDistance) {\n\n            // snap the marker\n            marker.setLatLng(closestLatLng);\n            this._onMarkerDrag(e);\n        }\n    },\n    _createSnapList: function _createSnapList() {\n        var _this2 = this;\n\n        var layers = [];\n        var debugIndicatorLines = [];\n\n        // find all layers that are or inherit from Polylines...\n        this._poly._map.eachLayer(function (layer) {\n            if (layer instanceof L.Polyline) {\n                layers.push(layer);\n                debugIndicatorLines.push(L.polyline([], { color: 'red' }).addTo(_this2._poly._map));\n            }\n        });\n\n        // ...except myself\n        layers = layers.filter(function (layer) {\n            return _this2._poly !== layer;\n        });\n\n        this._snapList = layers;\n        this.debugIndicatorLines = debugIndicatorLines;\n    },\n    _calcClosestLayer: function _calcClosestLayer(latlng, layers) {\n        var _this3 = this;\n\n        var map = this._poly._map;\n\n        // the closest polygon to our dragged marker latlng\n        var closestPolygon = void 0;\n\n        // the closest latlng of that polygon\n        var closestLatLng = void 0;\n\n        // the distance to that latlng\n        var closestDistance = void 0;\n\n        // loop through the layers\n        layers.forEach(function (layer, index) {\n\n            // find the closest latlng of this layer to the dragged marker latlng\n            var closestLatLngOfPoly = _this3._getClosestLayerLatlng(latlng, layer);\n\n            // show indicator lines, it's for debugging\n            _this3.debugIndicatorLines[index].setLatLngs([latlng, closestLatLngOfPoly]);\n\n            // the point of the marker latlng\n            var P = map.latLngToLayerPoint(latlng);\n\n            // the closest point of the polygon to P\n            var C = map.latLngToLayerPoint(closestLatLngOfPoly);\n\n            // the distance between P and C\n            var distance = P.distanceTo(C);\n\n            // save the info if it doesn't exist or if the distance is smaller than the previous one\n            if (closestDistance === undefined || distance < closestDistance) {\n                closestDistance = distance;\n                closestLatLng = closestLatLngOfPoly;\n                closestPolygon = layer;\n            }\n        });\n\n        // return the closest polygon, it's closest latlng and the distance\n        return {\n            layer: closestPolygon,\n            closestLatLng: closestLatLng,\n            distance: closestDistance\n        };\n    },\n    _getClosestLayerLatlng: function _getClosestLayerLatlng(latlng, layer) {\n        var map = this._poly._map;\n\n        // the point which we want to snap (probpably the marker that is dragged) in pixels\n        var P = map.latLngToLayerPoint(latlng);\n\n        // the coords of the layer\n        var coords = layer.getLatLngs()[0];\n\n        // temp var for the shortest distance\n        var shortestDistance = void 0;\n\n        // temp var for the shortest segment (line between two points) of the layer (polygon)\n        var closestSegment = void 0;\n\n        // loop through the coords of the layer\n        coords.forEach(function (point, index) {\n            // take this (A) and the next (B) coord\n            var nextIndex = index + 1 === coords.length ? 0 : index + 1;\n            var A = map.latLngToLayerPoint(point);\n\n            var B = map.latLngToLayerPoint(coords[nextIndex]);\n\n            // calc the distance between P and AB-segment\n            var distance = L.LineUtil.pointToSegmentDistance(P, A, B);\n\n            // is the distance shorter than the previous one? Save it and the segment\n            if (shortestDistance === undefined || distance < shortestDistance) {\n                shortestDistance = distance;\n                closestSegment = [A, B];\n            }\n        });\n\n        // now, take the closest segment (closestSegment) and calc the closest point to P on it.\n        var closestPoint = L.LineUtil.closestPointOnSegment(P, closestSegment[0], closestSegment[1]);\n\n        // return the latlng of that sucker\n        return map.layerPointToLatLng(closestPoint);\n    }\n};\n\"use strict\";\n\n/**\n*\n* A Leaflet Plugin For Editing Geometry Layers in Leaflet 1.0\n* by Sumit Kumar (@TweetsOfSumit)\n* Github Repo: https://github.com/codeofsumit/leaflet.pm\n*/\n\nL.PM = L.PM || {\n    initialize: function initialize() {\n\n        var initLayerGroup = function initLayerGroup() {\n            this.pm = new L.PM.Edit.LayerGroup(this);\n        };\n        L.LayerGroup.addInitHook(initLayerGroup);\n\n        var initPolygon = function initPolygon() {\n            this.pm = new L.PM.Edit.Poly(this);\n        };\n        L.Polygon.addInitHook(initPolygon);\n\n        var initMap = function initMap() {\n            this.pm = new L.PM.Map(this);\n        };\n        L.Map.addInitHook(initMap);\n    }\n};\n\n// initialize leaflet.pm\nL.PM.initialize();\n'use strict';\n\nL.PM.Map = L.Class.extend({\n    initialize: function initialize(map) {\n        this.map = map;\n        this.Draw = new L.PM.Draw(map);\n        this.Toolbar = new L.PM.Toolbar(map);\n    },\n\n    addControls: function addControls(options) {\n        this.Toolbar.addControls(options);\n    },\n    enableDraw: function enableDraw() {\n        var shape = arguments.length <= 0 || arguments[0] === undefined ? 'Poly' : arguments[0];\n\n        this.Draw.enable(shape);\n    },\n    disableDraw: function disableDraw() {\n        var shape = arguments.length <= 0 || arguments[0] === undefined ? 'Poly' : arguments[0];\n\n        this.Draw.disable(shape);\n    },\n    removeLayer: function removeLayer(e) {\n\n        var layer = e.target;\n        if (!layer._layers && !layer.pm.dragging()) {\n            e.target.remove();\n        }\n    },\n    toggleRemoval: function toggleRemoval(enabled) {\n        var _this = this;\n\n        if (enabled) {\n            this.map.eachLayer(function (layer) {\n                layer.on('click', _this.removeLayer);\n            });\n        } else {\n            this.map.eachLayer(function (layer) {\n                layer.off('click', _this.removeLayer);\n            });\n        }\n    }\n});\n'use strict';\n\nL.PM.Draw = L.Class.extend({\n\n    initialize: function initialize(map) {\n        var _this = this;\n\n        // save the map\n        this._map = map;\n\n        // define all possible shapes that can be drawn\n        this.shapes = ['Poly'];\n\n        // initiate drawing class for our shapes\n        this.shapes.forEach(function (shape) {\n            _this[shape] = new L.PM.Draw[shape](_this._map);\n        });\n    },\n    getShapes: function getShapes() {\n        // if somebody wants to know what shapes are available\n        return this.shapes;\n    },\n    enable: function enable(shape) {\n\n        if (!shape) {\n            throw 'Error: Please pass a shape as a parameter. Possible shapes are: ' + this.getShapes().join(',');\n        }\n\n        // disable drawing for all shapes\n        this.disable();\n\n        // enable draw for a shape\n        this[shape].enable();\n    },\n    disable: function disable() {\n        var _this2 = this;\n\n        // there can only be one drawing mode active at a time on a map\n        // so it doesn't matter which one should be disabled.\n        // just disable all of them\n        this.shapes.forEach(function (shape) {\n            _this2[shape].disable();\n        });\n    },\n    addControls: function addControls() {\n        var _this3 = this;\n\n        // add control buttons for our shapes\n        this.shapes.forEach(function (shape) {\n            _this3[shape].addButton();\n        });\n    }\n});\n\"use strict\";\n\nL.PM.Edit = L.Class.extend({\n    includes: [DragMixin, SnapMixin]\n});\n'use strict';\n\nL.PM.Draw.Poly = L.PM.Draw.extend({\n\n    initialize: function initialize(map) {\n        this._map = map;\n        this._shape = 'Poly';\n        this.registerButton();\n        this.toolbarButtonName = 'drawPolygon';\n    },\n    enable: function enable(options) {\n        // enable draw mode\n\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the polyLine that'll make up the polygon\n        this._polyline = L.polyline([], { color: 'red' });\n        this._layerGroup.addLayer(this._polyline);\n\n        // this is the hintline from the mouse cursor to the last marker\n        this._hintline = L.polyline([], {\n            color: 'red',\n            dashArray: [5, 5]\n        });\n        this._layerGroup.addLayer(this._hintline);\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._createPolygonPoint, this);\n\n        // sync the hintline on mousemove\n        this._map.on('mousemove', this._syncHintLine, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n    },\n    disable: function disable() {\n        // disable draw mode\n\n        // cancel, if drawing mode isn't even enabled\n        if (!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._createPolygonPoint);\n        this._map.off('mousemove', this._syncHintLine);\n\n        // remove layer\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    toggle: function toggle(options) {\n\n        if (this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    registerButton: function registerButton(map) {\n\n        var drawPolyButton = {\n            'className': 'icon-polygon',\n            'onClick': function onClick() {},\n            'afterClick': function afterClick(e) {\n                self.toggle();\n            },\n            'doToggle': true,\n            'toggleStatus': false\n        };\n\n        // this._drawButton = L.PM.Toolbar.addButton('drawPolygon', new L.Control.PMButton(drawPolyButton));\n        //\n        // this._map.on('pm:drawstart', (e) => {\n        //     if(e.shape === this._shape && !this._drawButton.toggled()) {\n        //         this._drawButton._clicked();\n        //     }\n        // });\n        //\n        // this._map.on('pm:drawend', (e) => {\n        //     if(e.shape === this._shape && this._drawButton.toggled()) {\n        //         this._drawButton._clicked();\n        //     }\n        // });\n\n    },\n    _syncHintLine: function _syncHintLine(e) {\n\n        var polyPoints = this._polyline.getLatLngs();\n\n        if (polyPoints.length > 0) {\n            var lastPolygonPoint = polyPoints[polyPoints.length - 1];\n            this._hintline.setLatLngs([lastPolygonPoint, e.latlng]);\n        }\n    },\n    _createPolygonPoint: function _createPolygonPoint(e) {\n\n        // is this the first point?\n        var first = this._polyline.getLatLngs().length === 0 ? true : false;\n\n        this._polyline.addLatLng(e.latlng);\n        this._createMarker(e.latlng, first);\n\n        this._hintline.setLatLngs([e.latlng, e.latlng]);\n    },\n    _finishPolygon: function _finishPolygon() {\n\n        var coords = this._polyline.getLatLngs();\n        var polygonLayer = L.polygon(coords).addTo(this._map);\n\n        polygonLayer.pm.toggleEdit();\n\n        this.disable();\n\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polygonLayer\n        });\n    },\n    _createMarker: function _createMarker(latlng, first) {\n\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        this._layerGroup.addLayer(marker);\n\n        if (first) {\n            marker.on('click', this._finishPolygon, this);\n        }\n\n        return marker;\n    }\n});\n'use strict';\n\n// LayerGroup doesn't inherit from L.PM.Edit because it's just calling L.PM.Edit.Poly\n// (which inherits from L.PM.Edit) for each layer,\n// so it's not really a parent class\nL.PM.Edit.LayerGroup = L.Class.extend({\n    initialize: function initialize(layerGroup) {\n        var _this = this;\n\n        this._layerGroup = layerGroup;\n        this._layers = layerGroup.getLayers();\n\n        var availableEvents = ['pm:edit', 'pm:dragstart', 'pm:drag', 'pm:dragend'];\n\n        this._layers.forEach(function (layer) {\n\n            // listen to the events of the layers in this group\n            availableEvents.forEach(function (event) {\n                layer.on(event, _this._fireEvent, _this);\n            });\n\n            // add reference for the group to each layer inside said group\n            layer.pm._layerGroup = _this._layerGroup;\n        });\n\n        // if a new layer is added to the group, reinitialize\n        // This only works for FeatureGroups, not LayerGroups\n        // https://github.com/Leaflet/Leaflet/issues/4861\n        this._layerGroup.on('layeradd', function (e) {\n\n            _this.initialize(layerGroup);\n\n            // if editing was already enabled for this group, enable it again\n            // so the new layers are enabled\n            if (e.target.pm.enabled()) {\n                _this.enable(_this.getOptions());\n            }\n        });\n    },\n    _fireEvent: function _fireEvent(e) {\n        this._layerGroup.fireEvent(e.type, e);\n    },\n    toggleEdit: function toggleEdit(options) {\n        this._options = options;\n        this._layers.forEach(function (layer) {\n            layer.pm.toggleEdit(options);\n        });\n    },\n    enable: function enable(options) {\n        this._options = options;\n        this._layers.forEach(function (layer) {\n            layer.pm.enable(options);\n        });\n    },\n    disable: function disable() {\n        this._layers.forEach(function (layer) {\n            layer.pm.disable();\n        });\n    },\n    enabled: function enabled() {\n        var enabled = this._layers.find(function (layer) {\n            return layer.pm.enabled();\n        });\n        return !!enabled;\n    },\n    dragging: function dragging() {\n        var dragging = this._layers.find(function (layer) {\n            return layer.pm.dragging();\n        });\n        return !!dragging;\n    },\n    getOptions: function getOptions() {\n        return this._options;\n    }\n});\n'use strict';\n\nL.PM.Edit.Poly = L.PM.Edit.extend({\n    initialize: function initialize(poly) {\n        this._poly = poly;\n        this._enabled = false;\n    },\n\n    toggleEdit: function toggleEdit(options) {\n        if (!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n\n    enable: function enable() {\n        var _this = this;\n\n        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\n        this.options = options;\n\n        if (!this.enabled()) {\n            // change state\n            this._enabled = true;\n\n            // init markers\n            this._initMarkers();\n\n            // if polygon gets removed from map, disable edit mode\n            this._poly.on('remove', function (e) {\n                _this.disable(e.target);\n            });\n\n            // preventOverlap needs the turf library. If it's not included, deactivate it again\n            // if(window.turf === undefined && this.options.preventOverlap) {\n            //     console.warn('TurfJS not found, preventOverlap is deactivated');\n            //     this.options.preventOverlap = false;\n            // }\n\n            if (this.options.draggable) {\n                this._initDraggableLayer();\n            }\n\n            // if(this.options.preventOverlap) {\n            //\n            //     // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n            //     this._poly.on('pm:drag', this._handleOverlap, this);\n            //\n            //     // set new coordinates, more details inside the function\n            //     this._poly.on('pm:dragend', this._applyPossibleCoordsChanges, this);\n            // }\n        }\n    },\n\n    enabled: function enabled() {\n        return this._enabled;\n    },\n\n    disable: function disable() {\n        var poly = arguments.length <= 0 || arguments[0] === undefined ? this._poly : arguments[0];\n\n\n        // prevent disabling if polygon is being dragged\n        if (poly.pm._dragging) {\n            return false;\n        }\n        poly.pm._enabled = false;\n        poly.pm._markerGroup.clearLayers();\n\n        // clean up draggable\n        poly.off('mousedown');\n        poly.off('mouseup');\n\n        // remove draggable class\n        var el = poly._path;\n        L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n    },\n\n    _initMarkers: function _initMarkers() {\n        var map = this._poly._map;\n\n        // cleanup old ones first\n        if (this._markerGroup) {\n            this._markerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._markerGroup = new L.LayerGroup();\n        map.addLayer(this._markerGroup);\n\n        // create marker for each coordinate\n        var coords = this._poly._latlngs[0];\n\n        // the marker array, it includes only the markers that're associated with the coordinates\n        this._markers = coords.map(this._createMarker, this);\n\n        // create small markers in the middle of the regular markers\n        for (var k = 0; k < coords.length; k++) {\n\n            var nextIndex = k + 1 >= coords.length ? 0 : k + 1;\n            this._createMiddleMarker(this._markers[k], this._markers[nextIndex]);\n        }\n\n        if (this.options.snap) {\n            this._initSnappableMarkers();\n        }\n    },\n\n    // creates initial markers for coordinates\n    _createMarker: function _createMarker(latlng, index) {\n\n        var marker = new L.Marker(latlng, {\n            draggable: true,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        marker._origLatLng = latlng;\n        marker._index = index;\n\n        marker.on('drag', this._onMarkerDrag, this);\n        marker.on('dragend', this._onMarkerDragEnd, this);\n        marker.on('contextmenu', this._removeMarker, this);\n\n        this._markerGroup.addLayer(marker);\n\n        return marker;\n    },\n\n    // creates the middle markes between coordinates\n    _createMiddleMarker: function _createMiddleMarker(leftM, rightM) {\n        var _this2 = this;\n\n        var latlng = this._calcMiddleLatLng(leftM.getLatLng(), rightM.getLatLng());\n\n        var middleMarker = this._createMarker(latlng);\n        var icon = L.divIcon({ className: 'marker-icon marker-icon-middle' });\n        middleMarker.setIcon(icon);\n\n        // save reference to this middle markers on the neighboor regular markers\n        leftM._middleMarkerNext = middleMarker;\n        rightM._middleMarkerPrev = middleMarker;\n\n        middleMarker.on('click', function () {\n\n            // TODO: move the next two lines inside _addMarker() as soon as\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            // is fixed\n            var icon = L.divIcon({ className: 'marker-icon' });\n            middleMarker.setIcon(icon);\n\n            _this2._addMarker(middleMarker, leftM, rightM);\n        });\n        middleMarker.on('movestart', function () {\n\n            // TODO: This is a workaround. Remove the moveend listener and callback as soon as this is fixed:\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            middleMarker.on('moveend', function () {\n                var icon = L.divIcon({ className: 'marker-icon' });\n                middleMarker.setIcon(icon);\n\n                middleMarker.off('moveend');\n            });\n\n            _this2._addMarker(middleMarker, leftM, rightM);\n        });\n    },\n\n    // adds a new marker from a middlemarker\n    _addMarker: function _addMarker(newM, leftM, rightM) {\n\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        var latlng = newM.getLatLng();\n        var coords = this._poly._latlngs[0];\n        var index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array & update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        this._markers.map(function (marker, i) {\n            return marker._index = i;\n        });\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n\n        if (this.options.snap) {\n            this._initSnappableMarkers();\n        }\n    },\n\n    _removeMarker: function _removeMarker(e) {\n        var marker = e.target;\n        var coords = this._poly._latlngs[0];\n        var index = marker._index;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if (index === undefined) {\n            return;\n        }\n\n        // remove polygon coordinate from this marker\n        coords.splice(index, 1);\n\n        // if the poly has no coordinates left, remove the layer\n        // else, redraw it\n        if (coords.length < 1) {\n            this._poly.remove();\n        } else {\n            this._poly.redraw();\n        }\n\n        // remove the marker and the middlemarkers next to it from the map\n        this._markerGroup.removeLayer(marker._middleMarkerPrev);\n        this._markerGroup.removeLayer(marker._middleMarkerNext);\n        this._markerGroup.removeLayer(marker);\n\n        // find neighbor marker-indexes\n        var leftMarkerIndex = index - 1 < 0 ? this._markers.length - 1 : index - 1;\n        var rightMarkerIndex = index + 1 >= this._markers.length ? 0 : index + 1;\n\n        // don't create middlemarkers if there is only one marker left\n        if (rightMarkerIndex !== leftMarkerIndex) {\n            var leftM = this._markers[leftMarkerIndex];\n            var rightM = this._markers[rightMarkerIndex];\n            this._createMiddleMarker(leftM, rightM);\n        }\n\n        // remove the marker from the markers array & update indexes\n        this._markers.splice(index, 1);\n        this._markers.map(function (marker, i) {\n            return marker._index = i;\n        });\n\n        // if the polygon should be cutted when overlapping another polygon, do it now\n        // if(this.options.preventOverlap) {\n        //     this._handleOverlap();\n        //     this._applyPossibleCoordsChanges();\n        // }\n\n        // fire edit event\n        this._fireEdit();\n    },\n\n    _onMarkerDrag: function _onMarkerDrag(e) {\n\n        // dragged marker\n        var marker = e.target;\n\n        // the dragged markers neighbors\n        var nextMarkerIndex = marker._index + 1 >= this._markers.length ? 0 : marker._index + 1;\n        var prevMarkerIndex = marker._index - 1 < 0 ? this._markers.length - 1 : marker._index - 1;\n\n        // update marker coordinates which will update polygon coordinates\n        L.extend(marker._origLatLng, marker._latlng);\n        this._poly.redraw();\n\n        // update middle markers on the left and right\n        // be aware that \"next\" and \"prev\" might be interchanged, depending on the geojson array\n        var markerLatLng = marker.getLatLng();\n        var prevMarkerLatLng = this._markers[prevMarkerIndex].getLatLng();\n        var nextMarkerLatLng = this._markers[nextMarkerIndex].getLatLng();\n\n        var middleMarkerNextLatLng = this._calcMiddleLatLng(markerLatLng, nextMarkerLatLng);\n        marker._middleMarkerNext.setLatLng(middleMarkerNextLatLng);\n\n        var middleMarkerPrevLatLng = this._calcMiddleLatLng(markerLatLng, prevMarkerLatLng);\n        marker._middleMarkerPrev.setLatLng(middleMarkerPrevLatLng);\n\n        // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n        // if(this.options.preventOverlap) {\n        //     this._handleOverlap();\n        // }\n    },\n\n    _onMarkerDragEnd: function _onMarkerDragEnd(e) {\n\n        // if(this.options.preventOverlap) {\n        //     this._applyPossibleCoordsChanges();\n        // }\n\n        // fire edit event\n        this._fireEdit();\n    },\n\n    _fireEdit: function _fireEdit() {\n        // fire edit event\n        this._poly.edited = true;\n        this._poly.fire('pm:edit');\n    },\n\n    _calcMiddleLatLng: function _calcMiddleLatLng(latlng1, latlng2) {\n        // calculate the middle coordinates between two markers\n        // TODO: put this into a utils.js or something\n\n        var map = this._poly._map,\n            p1 = map.project(latlng1),\n            p2 = map.project(latlng2);\n\n        var latlng = map.unproject(p1._add(p2)._divideBy(2));\n\n        return latlng;\n    }\n\n});\n'use strict';\n\nL.Control.PMButton = L.Control.extend({\n    options: {\n        position: 'topleft'\n    },\n    // TODO: clean up variable names like _button should be _options and that domNodeVariable stuff\n    initialize: function initialize(options) {\n        this._button = {};\n        this._button = this.setButton(options);\n    },\n\n    onAdd: function onAdd(map) {\n\n        this._map = map;\n\n        this._container = this._map.pm.Toolbar.container;\n        this.buttonsDomNode = this._makeButton(this._button);\n        this._container.appendChild(this.buttonsDomNode);\n\n        return this._container;\n    },\n\n    onRemove: function onRemove(map) {},\n\n    setButton: function setButton(options) {\n        var button = {\n            'className': options.className,\n            'iconUrl': options.iconUrl,\n            'onClick': options.onClick,\n            'afterClick': options.afterClick,\n            'doToggle': options.doToggle,\n            'toggleStatus': options.toggleStatus,\n            'disableOtherButtons': options.disableOtherButtons\n        };\n\n        return button;\n    },\n\n    getText: function getText() {\n        return this._button.text;\n    },\n\n    getIconUrl: function getIconUrl() {\n        return this._button.iconUrl;\n    },\n\n    destroy: function destroy() {\n        this._button = {};\n        this._update();\n    },\n\n    toggle: function toggle(e) {\n        if (typeof e === 'boolean') {\n            this._button.toggleStatus = e;\n        } else {\n            this._button.toggleStatus = !this._button.toggleStatus;\n        }\n        this._applyStyleClasses();\n\n        return this._button.toggleStatus;\n    },\n    toggled: function toggled() {\n        return this._button.toggleStatus;\n    },\n    onCreate: function onCreate() {\n        this.toggle(false);\n    },\n    _triggerClick: function _triggerClick(e) {\n        this._button.onClick(e);\n        this._clicked(e);\n        this._button.afterClick(e);\n    },\n    _makeButton: function _makeButton(button) {\n        var _this = this;\n\n        var newButton = L.DomUtil.create('a', 'leaflet-buttons-control-button', this._container);\n        if (button.toggleStatus) {\n            L.DomUtil.addClass(newButton, 'active');\n        }\n\n        var image = L.DomUtil.create('img', 'control-icon', newButton);\n        if (button.iconUrl) {\n            image.setAttribute('src', button.iconUrl);\n        }\n        if (button.className) {\n            L.DomUtil.addClass(image, button.className);\n        }\n        // before the actual click, trigger a click on currently toggled buttons to\n        // untoggle them and their functionality\n        L.DomEvent.addListener(newButton, 'click', function (e) {\n            if (_this._button.disableOtherButtons) {\n                _this._map.pm.Toolbar.triggerClickOnToggledButtons(_this);\n            }\n        });\n        L.DomEvent.addListener(newButton, 'click', this._triggerClick, this);\n\n        L.DomEvent.disableClickPropagation(newButton);\n        return newButton;\n    },\n\n    _applyStyleClasses: function _applyStyleClasses() {\n\n        if (!this._container) {\n            return;\n        }\n\n        if (!this._button.toggleStatus) {\n            L.DomUtil.removeClass(this.buttonsDomNode, 'active');\n        } else {\n            L.DomUtil.addClass(this.buttonsDomNode, 'active');\n        }\n    },\n\n    _clicked: function _clicked() {\n\n        if (this._button.doToggle) {\n            this.toggle();\n        }\n        return;\n    }\n\n});\n'use strict';\n\n/**\n* The Icons used in this Toolbar are CC-BY Glyphicons - http://glyphicons.com/\n*/\n\nL.PM.Toolbar = L.Class.extend({\n    options: {\n        drawPolygon: true,\n        editPolygon: false,\n        dragPolygon: false,\n        deleteLayer: true\n    },\n    initialize: function initialize(map) {\n        this.map = map;\n\n        this.buttons = {};\n        this.container = L.DomUtil.create('div', 'leaflet-pm-toolbar leaflet-bar leaflet-control');\n        this._defineButtons();\n    },\n\n    getButtons: function getButtons() {\n        return this.buttons;\n    },\n\n    addControls: function addControls() {\n        var options = arguments.length <= 0 || arguments[0] === undefined ? this.options : arguments[0];\n\n        // adds all buttons to the map specified inside options\n\n        // first set the options\n        L.Util.setOptions(this, options);\n\n        // now show the specified buttons\n        this._showHideButtons();\n    },\n    _addButton: function _addButton(name, button) {\n        this.buttons[name] = button;\n        this.options[name] = this.options[name] || false;\n\n        return this.buttons[name];\n    },\n    triggerClickOnToggledButtons: function triggerClickOnToggledButtons(exceptThisButton) {\n        // this function is used when - e.g. drawing mode is enabled and a possible\n        // other active mode (like removal tool) is already active.\n        // we can't have two active modes because of possible event conflicts\n        // so, we trigger a click on all currently active (toggled) buttons\n        for (var name in this.buttons) {\n            if (this.buttons[name] !== exceptThisButton && this.buttons[name].toggled()) {\n                this.buttons[name]._triggerClick();\n            }\n        }\n    },\n    toggleButton: function toggleButton(name, status) {\n        // does not fire the events/functionality of the button\n        // this just changes the state and is used if a functionality (like Draw)\n        // is enabled manually via script\n\n        // as some mode got enabled, we still have to trigger the click on the other buttons\n        // to disable their mode\n        this.triggerClickOnToggledButtons(this.buttons[name]);\n\n        // now toggle the state of the button\n        return this.buttons[name].toggle(status);\n    },\n    _defineButtons: function _defineButtons() {\n        var _this = this;\n\n        // some buttons are still in their respective classes, like L.PM.Draw.Poly\n        var deleteButton = {\n            'className': 'icon-delete',\n            'onClick': function onClick(e) {},\n            'afterClick': function afterClick(e) {\n                _this.map.pm.toggleRemoval(_this.buttons.deleteLayer.toggled());\n            },\n            'doToggle': true,\n            'toggleStatus': false,\n            'disableOtherButtons': true\n        };\n\n        var drawPolyButton = {\n            'className': 'icon-polygon',\n            'onClick': function onClick(e) {},\n            'afterClick': function afterClick(e) {\n                // toggle drawing mode\n                _this.map.pm.Draw.Poly.toggle();\n            },\n            'doToggle': true,\n            'toggleStatus': false,\n            'disableOtherButtons': true\n        };\n\n        var editButton = {\n            'className': 'icon-edit',\n            'onClick': function onClick(e) {},\n            'afterClick': function afterClick(e) {},\n            'doToggle': true,\n            'toggleStatus': false,\n            'disableOtherButtons': true\n        };\n\n        var dragButton = {\n            'className': 'icon-drag',\n            'onClick': function onClick(e) {},\n            'afterClick': function afterClick(e) {},\n            'doToggle': true,\n            'toggleStatus': false,\n            'disableOtherButtons': true\n        };\n\n        this._addButton('drawPolygon', new L.Control.PMButton(drawPolyButton));\n        this._addButton('editPolygon', new L.Control.PMButton(editButton));\n        this._addButton('dragPolygon', new L.Control.PMButton(dragButton));\n        this._addButton('deleteLayer', new L.Control.PMButton(deleteButton));\n    },\n    _showHideButtons: function _showHideButtons() {\n        // loop through all buttons\n        var buttons = this.getButtons();\n\n        for (var btn in buttons) {\n            if (this.options[btn]) {\n                // if options say the button should be visible, add it to the map\n                buttons[btn].addTo(this.map);\n            } else {\n                // if not, remove it\n                buttons[btn].remove();\n            }\n        }\n    }\n});","var DragMixin = {\n    _initDraggableLayer: function() {\n        // temporary coord variable for delta calculation\n        this._tempDragCoord;\n\n        // add CSS class\n        var el = this._poly._path;\n        L.DomUtil.addClass(el, 'leaflet-pm-draggable');\n\n\n        var onMouseUp = (e) => {\n\n            // re-enable map drag\n            this._poly._map.dragging.enable();\n\n            // clear up mousemove event\n            this._poly._map.off('mousemove');\n\n            // clear up mouseup event\n            this._poly.off('mouseup');\n\n            // show markers again\n            this._initMarkers();\n\n            // timeout to prevent click event after drag :-/\n            // TODO: do it better as soon as leaflet has a way to do it better :-)\n            window.setTimeout(() => {\n                // set state\n                this._dragging = false;\n                L.DomUtil.removeClass(el, 'leaflet-pm-dragging');\n\n                // fire pm:dragend event\n                this._poly.fire('pm:dragend');\n\n                // fire edit\n                this._fireEdit();\n            }, 10);\n\n        }\n\n\n        var onMouseMove = (e) => {\n\n            if(!this._dragging) {\n\n                // set state\n                this._dragging = true;\n                L.DomUtil.addClass(el, 'leaflet-pm-dragging');\n\n                // bring it to front to prevent drag interception\n                this._poly.bringToFront();\n\n                // disbale map drag\n                this._poly._map.dragging.disable();\n\n                // hide markers\n                this._markerGroup.clearLayers();\n\n                // fire pm:dragstart event\n                this._poly.fire('pm:dragstart');\n\n\n            }\n\n            this._onLayerDrag(e);\n\n        }\n\n        this._poly.on('mousedown', (e) => {\n\n            // save for delta calculation\n            this._tempDragCoord = e.latlng;\n\n            this._poly.on('mouseup', onMouseUp);\n\n            // listen to mousemove on map (instead of polygon),\n            // otherwise fast mouse movements stop the drag\n            this._poly._map.on('mousemove', onMouseMove);\n\n        });\n    },\n    dragging: function() {\n        return this._dragging;\n    },\n\n    _onLayerDrag: function(e) {\n\n        // latLng of mouse event\n        let latlng = e.latlng;\n\n        // delta coords (how far was dragged)\n        let deltaLatLng = {\n            lat: latlng.lat - this._tempDragCoord.lat,\n            lng: latlng.lng - this._tempDragCoord.lng\n        };\n\n        // create the new coordinates array\n        let coords = this._poly._latlngs[0];\n        let newLatLngs = coords.map((currentLatLng) => {\n            return {\n                lat: currentLatLng.lat + deltaLatLng.lat,\n                lng: currentLatLng.lng + deltaLatLng.lng\n            }\n        });\n\n        // set new coordinates and redraw\n        this._poly.setLatLngs(newLatLngs).redraw();\n\n        // save current latlng for next delta calculation\n        this._tempDragCoord = latlng;\n\n        // fire pm:dragstart event\n        this._poly.fire('pm:drag');\n\n    },\n}\n","// this isn't included anymore but if you want to re-enable it:\n// 1. include this mixing inside L.PM.Edit.js\n// 2. include the turf.js dependency in your project before leaflet.pm\n// 3. uncomment all code inside L.PM.Edit.Poly that has an if-check on options.preventOverlap\n// 4. pass the option preventOverlap to the enable() function on your layer\nvar OverlapMixin = {\n\n    _applyPossibleCoordsChanges: function() {\n\n        // after the polygon was dragged and changed it's shape because of unallowed intersecting\n        // with another polygon, this function takes the temporarily drawn polygon (during drag) and applies\n        // it's coordinates to our main polygon\n\n        if(this._tempPolygon) {\n\n            // get the new coordinates\n            var latlngs = this._tempPolygon.getLayers()[0].getLatLngs();\n\n            // reshape our main polygon\n            this._poly.setLatLngs(latlngs).redraw();\n\n            // initialize the markers again\n            this._initMarkers();\n        }\n\n    },\n\n    _drawTemporaryPolygon: function(geoJson) {\n\n        // hide our polygon\n        this._poly.setStyle({opacity: 0, fillOpacity: 0});\n\n        // draw a temporary polygon (happens during drag & intersection)\n        this._tempPolygon = L.geoJson(geoJson).addTo(this._poly._map).bringToBack();\n\n    },\n\n    _handleOverlap: function() {\n\n        let mainPoly = this._poly;\n        let layers = this._layerGroup.getLayers();\n        let changed = false;\n        let resultingGeoJson = this._poly.toGeoJSON();\n\n        layers\n        .filter(layer => !Object.is(layer, mainPoly))\n        .map((layer) => {\n\n            let intersect;\n\n            // this needs to be in a try catch block because turf isn't reliable\n            // it throws self-intersection errors even if there are none\n            try {\n                intersect = turf.intersect(resultingGeoJson, layer.toGeoJSON());\n            } catch(e) {\n                console.warn('Turf Error.');\n            }\n\n            if(intersect) {\n                resultingGeoJson = turf.difference(resultingGeoJson, layer.toGeoJSON());\n\n                // if the resulting polygon is a MultiPolygon, don't handle it.\n                if(resultingGeoJson.geometry.type !== 'MultiPolygon') {\n                    changed = true;\n                }\n            }\n\n        });\n\n        if(this._tempPolygon) {\n            this._tempPolygon.remove();\n            delete this._tempPolygon;\n        }\n\n        if(changed) {\n            this._drawTemporaryPolygon(resultingGeoJson);\n        } else {\n            this._poly.setStyle({opacity: 1, fillOpacity: 0.2});\n        }\n\n\n\n    }\n}\n","var SnapMixin = {\n    _initSnappableMarkers: function() {\n\n        this._markers.forEach((marker) => {\n\n            marker.off('drag', this._handleSnapping, this);\n            marker.on('drag', this._handleSnapping, this);\n\n            marker.off('dragend', this._cleanupSnapping, this);\n            marker.on('dragend', this._cleanupSnapping, this);\n        });\n\n    },\n    _cleanupSnapping: function(e) {\n        console.log('drag end');\n\n        delete this._snapList;\n\n        this.debugIndicatorLines.forEach((line) => {\n            line.remove();\n        });\n    },\n    _handleSnapping: function(e) {\n\n        if(this._snapList === undefined) {\n            this._createSnapList(e);\n        }\n\n\n\n        let marker = e.target;\n\n        // get the closest layer, it's closest latlng and the distance\n        let {layer, closestLatLng, distance} = this._calcClosestLayer(marker.getLatLng(), this._snapList);\n\n        // minimal distance before marker snaps (in pixels)\n        let minDistance = 30;\n\n        if(distance < minDistance) {\n\n            // snap the marker\n            marker.setLatLng(closestLatLng);\n            this._onMarkerDrag(e);\n        }\n\n    },\n    _createSnapList: function() {\n\n        let layers = [];\n        let debugIndicatorLines = [];\n\n        // find all layers that are or inherit from Polylines...\n        this._poly._map.eachLayer((layer) => {\n            if(layer instanceof L.Polyline) {\n                layers.push(layer);\n                debugIndicatorLines.push(L.polyline([], {color: 'red'}).addTo(this._poly._map));\n            }\n        });\n\n        // ...except myself\n        layers = layers.filter((layer) => {\n            return this._poly !== layer\n        });\n\n        this._snapList = layers;\n        this.debugIndicatorLines = debugIndicatorLines;\n    },\n    _calcClosestLayer: function(latlng, layers) {\n        let map = this._poly._map;\n\n        // the closest polygon to our dragged marker latlng\n        let closestPolygon;\n\n        // the closest latlng of that polygon\n        let closestLatLng;\n\n        // the distance to that latlng\n        let closestDistance;\n\n        // loop through the layers\n        layers.forEach((layer, index) => {\n\n            // find the closest latlng of this layer to the dragged marker latlng\n            let closestLatLngOfPoly = this._getClosestLayerLatlng(latlng, layer);\n\n            // show indicator lines, it's for debugging\n            this.debugIndicatorLines[index].setLatLngs([latlng, closestLatLngOfPoly]);\n\n            // the point of the marker latlng\n            let P = map.latLngToLayerPoint(latlng);\n\n            // the closest point of the polygon to P\n            let C = map.latLngToLayerPoint(closestLatLngOfPoly);\n\n            // the distance between P and C\n            let distance = P.distanceTo(C);\n\n            // save the info if it doesn't exist or if the distance is smaller than the previous one\n            if(closestDistance === undefined || distance < closestDistance) {\n                closestDistance = distance;\n                closestLatLng = closestLatLngOfPoly;\n                closestPolygon = layer;\n            }\n\n        });\n\n        // return the closest polygon, it's closest latlng and the distance\n        return {\n            layer: closestPolygon,\n            closestLatLng,\n            distance: closestDistance\n        };\n\n\n    },\n    _getClosestLayerLatlng: function(latlng, layer) {\n        let map = this._poly._map;\n\n        // the point which we want to snap (probpably the marker that is dragged) in pixels\n        let P = map.latLngToLayerPoint(latlng);\n\n        // the coords of the layer\n        let coords = layer.getLatLngs()[0];\n\n        // temp var for the shortest distance\n        let shortestDistance;\n\n        // temp var for the shortest segment (line between two points) of the layer (polygon)\n        let closestSegment;\n\n        // loop through the coords of the layer\n        coords.forEach((point, index) => {\n            // take this (A) and the next (B) coord\n            let nextIndex = index + 1 === coords.length ? 0 : index + 1;\n            let A = map.latLngToLayerPoint(point);\n\n            let B = map.latLngToLayerPoint(coords[nextIndex]);\n\n            // calc the distance between P and AB-segment\n            let distance = L.LineUtil.pointToSegmentDistance(P, A, B);\n\n            // is the distance shorter than the previous one? Save it and the segment\n            if(shortestDistance === undefined || distance < shortestDistance) {\n                shortestDistance = distance;\n                closestSegment = [A, B];\n            }\n\n        });\n\n        // now, take the closest segment (closestSegment) and calc the closest point to P on it.\n        let closestPoint = L.LineUtil.closestPointOnSegment(P, closestSegment[0], closestSegment[1]);\n\n        // return the latlng of that sucker\n        return map.layerPointToLatLng(closestPoint);\n\n    }\n}\n","/**\n*\n* A Leaflet Plugin For Editing Geometry Layers in Leaflet 1.0\n* by Sumit Kumar (@TweetsOfSumit)\n* Github Repo: https://github.com/codeofsumit/leaflet.pm\n*/\n\nL.PM = L.PM || {\n    initialize: function() {\n\n        var initLayerGroup = function() {\n            this.pm = new L.PM.Edit.LayerGroup(this);\n        };\n        L.LayerGroup.addInitHook(initLayerGroup);\n\n\n        var initPolygon = function() {\n            this.pm = new L.PM.Edit.Poly(this);\n        };\n        L.Polygon.addInitHook(initPolygon);\n\n\n        var initMap = function() {\n            this.pm = new L.PM.Map(this);\n        };\n        L.Map.addInitHook(initMap);\n\n    }\n};\n\n// initialize leaflet.pm\nL.PM.initialize();\n","L.PM.Map = L.Class.extend({\n    initialize(map) {\n        this.map = map;\n        this.Draw = new L.PM.Draw(map);\n        this.Toolbar = new L.PM.Toolbar(map);\n    },\n    addControls: function(options) {\n        this.Toolbar.addControls(options);\n    },\n    enableDraw: function(shape = 'Poly') {\n        this.Draw.enable(shape);\n    },\n    disableDraw: function(shape = 'Poly') {\n        this.Draw.disable(shape);\n    },\n    removeLayer: function(e) {\n\n        var layer = e.target;\n        if(!layer._layers && !layer.pm.dragging()) {\n            e.target.remove();\n        }\n    },\n    toggleRemoval: function(enabled) {\n        if(enabled) {\n            this.map.eachLayer((layer) => {\n                layer.on('click', this.removeLayer);\n            });\n        } else {\n            this.map.eachLayer((layer) => {\n                layer.off('click', this.removeLayer);\n            });\n        }\n\n\n\n    },\n});\n","L.PM.Draw = L.Class.extend({\n\n    initialize: function(map) {\n\n        // save the map\n        this._map = map;\n\n        // define all possible shapes that can be drawn\n        this.shapes = ['Poly'];\n\n        // initiate drawing class for our shapes\n        this.shapes.forEach((shape) => {\n            this[shape] = new L.PM.Draw[shape](this._map);\n        });\n\n    },\n    getShapes: function() {\n        // if somebody wants to know what shapes are available\n        return this.shapes;\n    },\n    enable: function(shape) {\n\n        if(!shape) {\n            throw 'Error: Please pass a shape as a parameter. Possible shapes are: ' + this.getShapes().join(',');\n        }\n\n        // disable drawing for all shapes\n        this.disable();\n\n        // enable draw for a shape\n        this[shape].enable();\n\n    },\n    disable: function() {\n\n        // there can only be one drawing mode active at a time on a map\n        // so it doesn't matter which one should be disabled.\n        // just disable all of them\n        this.shapes.forEach((shape) => {\n            this[shape].disable();\n        });\n\n    },\n    addControls: function() {\n        // add control buttons for our shapes\n        this.shapes.forEach((shape) => {\n            this[shape].addButton();\n        });\n    }\n});\n","L.PM.Edit = L.Class.extend({\n    includes: [DragMixin, SnapMixin]\n});\n","L.PM.Draw.Poly = L.PM.Draw.extend({\n\n    initialize: function(map) {\n        this._map = map;\n        this._shape = 'Poly';\n        this.registerButton();\n        this.toolbarButtonName = 'drawPolygon';\n    },\n    enable: function(options) {\n        // enable draw mode\n\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the polyLine that'll make up the polygon\n        this._polyline = L.polyline([], {color: 'red'});\n        this._layerGroup.addLayer(this._polyline);\n\n        // this is the hintline from the mouse cursor to the last marker\n        this._hintline = L.polyline([], {\n            color: 'red',\n            dashArray: [5, 5]\n        });\n        this._layerGroup.addLayer(this._hintline);\n\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._createPolygonPoint, this);\n\n        // sync the hintline on mousemove\n        this._map.on('mousemove', this._syncHintLine, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', {shape: this._shape});\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n\n    },\n    disable: function() {\n        // disable draw mode\n\n        // cancel, if drawing mode isn't even enabled\n        if(!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._createPolygonPoint);\n        this._map.off('mousemove', this._syncHintLine);\n\n        // remove layer\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', {shape: this._shape});\n\n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n\n    },\n    enabled: function() {\n        return this._enabled;\n    },\n    toggle: function(options) {\n\n        if(this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n\n    },\n    registerButton: function(map) {\n\n        var drawPolyButton = {\n            'className': 'icon-polygon',\n            'onClick': function() {\n\n            },\n            'afterClick': function(e) {\n                self.toggle();\n            },\n            'doToggle': true,\n            'toggleStatus': false\n        };\n\n\n        // this._drawButton = L.PM.Toolbar.addButton('drawPolygon', new L.Control.PMButton(drawPolyButton));\n        //\n        // this._map.on('pm:drawstart', (e) => {\n        //     if(e.shape === this._shape && !this._drawButton.toggled()) {\n        //         this._drawButton._clicked();\n        //     }\n        // });\n        //\n        // this._map.on('pm:drawend', (e) => {\n        //     if(e.shape === this._shape && this._drawButton.toggled()) {\n        //         this._drawButton._clicked();\n        //     }\n        // });\n\n\n\n    },\n    _syncHintLine: function(e) {\n\n        var polyPoints = this._polyline.getLatLngs();\n\n        if(polyPoints.length > 0) {\n            var lastPolygonPoint = polyPoints[polyPoints.length - 1];\n            this._hintline.setLatLngs([lastPolygonPoint, e.latlng]);\n        }\n\n\n\n    },\n    _createPolygonPoint: function(e) {\n\n        // is this the first point?\n        var first = this._polyline.getLatLngs().length === 0 ? true : false;\n\n        this._polyline.addLatLng(e.latlng);\n        this._createMarker(e.latlng, first);\n\n\n        this._hintline.setLatLngs([e.latlng, e.latlng]);\n\n    },\n    _finishPolygon: function() {\n\n        var coords = this._polyline.getLatLngs();\n        var polygonLayer = L.polygon(coords).addTo(this._map);\n\n        polygonLayer.pm.toggleEdit();\n\n        this.disable();\n\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polygonLayer\n        });\n    },\n    _createMarker: function(latlng, first) {\n\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({className: 'marker-icon'})\n        });\n\n        this._layerGroup.addLayer(marker);\n\n        if(first) {\n            marker.on('click', this._finishPolygon, this);\n        }\n\n        return marker;\n\n    },\n});\n","// LayerGroup doesn't inherit from L.PM.Edit because it's just calling L.PM.Edit.Poly\n// (which inherits from L.PM.Edit) for each layer,\n// so it's not really a parent class\nL.PM.Edit.LayerGroup = L.Class.extend({\n    initialize: function(layerGroup) {\n\n        this._layerGroup = layerGroup;\n        this._layers = layerGroup.getLayers();\n\n        let availableEvents = ['pm:edit', 'pm:dragstart', 'pm:drag', 'pm:dragend'];\n\n        this._layers.forEach((layer) => {\n\n            // listen to the events of the layers in this group\n            availableEvents.forEach((event) => {\n                layer.on(event, this._fireEvent, this);\n            });\n\n            // add reference for the group to each layer inside said group\n            layer.pm._layerGroup = this._layerGroup;\n        });\n\n\n        // if a new layer is added to the group, reinitialize\n        // This only works for FeatureGroups, not LayerGroups\n        // https://github.com/Leaflet/Leaflet/issues/4861\n        this._layerGroup.on('layeradd', (e) => {\n\n            this.initialize(layerGroup);\n\n            // if editing was already enabled for this group, enable it again\n            // so the new layers are enabled\n            if(e.target.pm.enabled()) {\n                this.enable(this.getOptions());\n            }\n        });\n    },\n    _fireEvent: function(e) {\n        this._layerGroup.fireEvent(e.type, e);\n    },\n    toggleEdit: function(options) {\n        this._options = options;\n        this._layers.forEach(layer => {\n            layer.pm.toggleEdit(options);\n        });\n    },\n    enable: function(options) {\n        this._options = options;\n        this._layers.forEach(layer => {\n            layer.pm.enable(options);\n        });\n    },\n    disable: function() {\n        this._layers.forEach(layer => {\n            layer.pm.disable();\n        });\n    },\n    enabled: function() {\n        let enabled = this._layers.find((layer) => layer.pm.enabled());\n        return !!enabled;\n    },\n    dragging: function() {\n        let dragging = this._layers.find((layer) => layer.pm.dragging());\n        return !!dragging;\n    },\n    getOptions: function() {\n        return this._options;\n    }\n});\n","L.PM.Edit.Poly = L.PM.Edit.extend({\n    initialize: function(poly) {\n        this._poly = poly;\n        this._enabled = false;\n    },\n\n    toggleEdit: function(options) {\n        if(!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n\n    enable: function(options = {}) {\n\n        this.options = options;\n\n        if(!this.enabled()) {\n            // change state\n            this._enabled = true;\n\n            // init markers\n            this._initMarkers();\n\n            // if polygon gets removed from map, disable edit mode\n            this._poly.on('remove', (e) => {\n                this.disable(e.target);\n            });\n\n            // preventOverlap needs the turf library. If it's not included, deactivate it again\n            // if(window.turf === undefined && this.options.preventOverlap) {\n            //     console.warn('TurfJS not found, preventOverlap is deactivated');\n            //     this.options.preventOverlap = false;\n            // }\n\n            if(this.options.draggable) {\n                this._initDraggableLayer();\n            }\n\n            // if(this.options.preventOverlap) {\n            //\n            //     // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n            //     this._poly.on('pm:drag', this._handleOverlap, this);\n            //\n            //     // set new coordinates, more details inside the function\n            //     this._poly.on('pm:dragend', this._applyPossibleCoordsChanges, this);\n            // }\n        }\n\n    },\n\n    enabled: function() {\n        return this._enabled;\n    },\n\n    disable: function(poly = this._poly) {\n\n        // prevent disabling if polygon is being dragged\n        if(poly.pm._dragging) {\n            return false;\n        }\n        poly.pm._enabled = false;\n        poly.pm._markerGroup.clearLayers();\n\n        // clean up draggable\n        poly.off('mousedown');\n        poly.off('mouseup');\n\n        // remove draggable class\n        var el = poly._path;\n        L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n    },\n\n    _initMarkers: function() {\n        let map = this._poly._map;\n\n        // cleanup old ones first\n        if(this._markerGroup) {\n            this._markerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._markerGroup = new L.LayerGroup();\n        map.addLayer(this._markerGroup);\n\n        // create marker for each coordinate\n        let coords = this._poly._latlngs[0];\n\n        // the marker array, it includes only the markers that're associated with the coordinates\n        this._markers = coords.map(this._createMarker, this);\n\n        // create small markers in the middle of the regular markers\n        for(var k = 0; k < coords.length; k++) {\n\n            var nextIndex = k+1 >= coords.length ? 0 : k+1;\n            this._createMiddleMarker(\n                this._markers[k], this._markers[nextIndex]\n            );\n        }\n\n        if(this.options.snap) {\n            this._initSnappableMarkers();\n        }\n\n    },\n\n    // creates initial markers for coordinates\n    _createMarker: function(latlng, index) {\n\n        let marker = new L.Marker(latlng, {\n            draggable: true,\n            icon: L.divIcon({className: 'marker-icon'})\n        });\n\n        marker._origLatLng = latlng;\n        marker._index = index;\n\n        marker.on('drag', this._onMarkerDrag, this);\n        marker.on('dragend', this._onMarkerDragEnd, this);\n        marker.on('contextmenu', this._removeMarker, this);\n\n        this._markerGroup.addLayer(marker);\n\n        return marker;\n\n    },\n\n    // creates the middle markes between coordinates\n    _createMiddleMarker: function(leftM, rightM) {\n\n        let latlng = this._calcMiddleLatLng(leftM.getLatLng(), rightM.getLatLng());\n\n        let middleMarker = this._createMarker(latlng);\n        let icon = L.divIcon({className: 'marker-icon marker-icon-middle'})\n        middleMarker.setIcon(icon);\n\n        // save reference to this middle markers on the neighboor regular markers\n        leftM._middleMarkerNext = middleMarker;\n        rightM._middleMarkerPrev = middleMarker;\n\n        middleMarker.on('click', () => {\n\n            // TODO: move the next two lines inside _addMarker() as soon as\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            // is fixed\n            var icon = L.divIcon({className: 'marker-icon'});\n            middleMarker.setIcon(icon);\n\n            this._addMarker(middleMarker, leftM, rightM);\n        });\n        middleMarker.on('movestart', () => {\n\n            // TODO: This is a workaround. Remove the moveend listener and callback as soon as this is fixed:\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            middleMarker.on('moveend', function() {\n                var icon = L.divIcon({className: 'marker-icon'});\n                middleMarker.setIcon(icon);\n\n                middleMarker.off('moveend');\n            });\n\n            this._addMarker(middleMarker, leftM, rightM);\n        });\n\n\n    },\n\n    // adds a new marker from a middlemarker\n    _addMarker: function(newM, leftM, rightM) {\n\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        let latlng = newM.getLatLng();\n        let coords = this._poly._latlngs[0];\n        let index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array & update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        this._markers.map((marker, i) => marker._index = i);\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n\n        if(this.options.snap) {\n            this._initSnappableMarkers();\n        }\n\n    },\n\n    _removeMarker: function(e) {\n        let marker = e.target;\n        let coords = this._poly._latlngs[0];\n        let index = marker._index;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if(index === undefined) {\n            return;\n        }\n\n        // remove polygon coordinate from this marker\n        coords.splice(index, 1);\n\n        // if the poly has no coordinates left, remove the layer\n        // else, redraw it\n        if(coords.length < 1) {\n            this._poly.remove();\n        } else {\n            this._poly.redraw();\n        }\n\n        // remove the marker and the middlemarkers next to it from the map\n        this._markerGroup.removeLayer(marker._middleMarkerPrev);\n        this._markerGroup.removeLayer(marker._middleMarkerNext);\n        this._markerGroup.removeLayer(marker);\n\n        // find neighbor marker-indexes\n        let leftMarkerIndex = index - 1 < 0 ? this._markers.length - 1 : index - 1;\n        let rightMarkerIndex = index + 1 >= this._markers.length ? 0 : index + 1;\n\n        // don't create middlemarkers if there is only one marker left\n        if(rightMarkerIndex !== leftMarkerIndex) {\n            let leftM = this._markers[leftMarkerIndex];\n            let rightM = this._markers[rightMarkerIndex];\n            this._createMiddleMarker(leftM, rightM);\n        }\n\n        // remove the marker from the markers array & update indexes\n        this._markers.splice(index, 1);\n        this._markers.map((marker, i) => marker._index = i);\n\n        // if the polygon should be cutted when overlapping another polygon, do it now\n        // if(this.options.preventOverlap) {\n        //     this._handleOverlap();\n        //     this._applyPossibleCoordsChanges();\n        // }\n\n        // fire edit event\n        this._fireEdit();\n\n\n    },\n\n\n\n    _onMarkerDrag: function(e) {\n\n        // dragged marker\n        let marker = e.target;\n\n        // the dragged markers neighbors\n        let nextMarkerIndex = marker._index + 1 >= this._markers.length ? 0 : marker._index + 1;\n        let prevMarkerIndex = marker._index - 1 < 0 ? this._markers.length - 1 : marker._index - 1;\n\n        // update marker coordinates which will update polygon coordinates\n        L.extend(marker._origLatLng, marker._latlng);\n        this._poly.redraw();\n\n        // update middle markers on the left and right\n        // be aware that \"next\" and \"prev\" might be interchanged, depending on the geojson array\n        let markerLatLng = marker.getLatLng();\n        let prevMarkerLatLng = this._markers[prevMarkerIndex].getLatLng();\n        let nextMarkerLatLng = this._markers[nextMarkerIndex].getLatLng();\n\n        let middleMarkerNextLatLng = this._calcMiddleLatLng(markerLatLng, nextMarkerLatLng);\n        marker._middleMarkerNext.setLatLng(middleMarkerNextLatLng);\n\n        let middleMarkerPrevLatLng = this._calcMiddleLatLng(markerLatLng, prevMarkerLatLng);\n        marker._middleMarkerPrev.setLatLng(middleMarkerPrevLatLng);\n\n        // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n        // if(this.options.preventOverlap) {\n        //     this._handleOverlap();\n        // }\n\n    },\n\n    _onMarkerDragEnd: function(e) {\n\n        // if(this.options.preventOverlap) {\n        //     this._applyPossibleCoordsChanges();\n        // }\n\n        // fire edit event\n        this._fireEdit();\n\n    },\n\n    _fireEdit: function () {\n        // fire edit event\n        this._poly.edited = true;\n        this._poly.fire('pm:edit');\n    },\n\n    _calcMiddleLatLng: function(latlng1, latlng2) {\n        // calculate the middle coordinates between two markers\n        // TODO: put this into a utils.js or something\n\n        var map = this._poly._map,\n            p1 = map.project(latlng1),\n            p2 = map.project(latlng2);\n\n        var latlng = map.unproject(p1._add(p2)._divideBy(2));\n\n        return latlng;\n    }\n\n});\n","L.Control.PMButton = L.Control.extend({\n    options: {\n        position: 'topleft'\n    },\n    // TODO: clean up variable names like _button should be _options and that domNodeVariable stuff\n    initialize: function (options) {\n        this._button = {};\n        this._button = this.setButton(options);\n    },\n\n    onAdd: function (map) {\n\n        this._map = map;\n\n        this._container = this._map.pm.Toolbar.container;\n        this.buttonsDomNode = this._makeButton(this._button);\n        this._container.appendChild(this.buttonsDomNode)\n\n        return this._container;\n    },\n\n    onRemove: function (map) {\n    },\n\n    setButton: function (options) {\n        var button = {\n            'className': options.className,\n            'iconUrl': options.iconUrl,\n            'onClick': options.onClick,\n            'afterClick': options.afterClick,\n            'doToggle': options.doToggle,\n            'toggleStatus': options.toggleStatus,\n            'disableOtherButtons': options.disableOtherButtons\n        };\n\n        return button;\n    },\n\n    getText: function () {\n        return this._button.text;\n    },\n\n    getIconUrl: function () {\n        return this._button.iconUrl;\n    },\n\n    destroy: function () {\n        this._button = {};\n        this._update();\n    },\n\n    toggle: function (e) {\n        if(typeof e === 'boolean'){\n            this._button.toggleStatus = e;\n        }\n        else{\n            this._button.toggleStatus = !this._button.toggleStatus;\n        }\n        this._applyStyleClasses();\n\n        return this._button.toggleStatus;\n    },\n    toggled: function () {\n        return this._button.toggleStatus;\n    },\n    onCreate: function() {\n        this.toggle(false);\n    },\n    _triggerClick: function(e) {\n        this._button.onClick(e);\n        this._clicked(e);\n        this._button.afterClick(e);\n    },\n    _makeButton: function(button) {\n\n        var newButton = L.DomUtil.create('a', 'leaflet-buttons-control-button', this._container);\n        if(button.toggleStatus) {\n            L.DomUtil.addClass(newButton,'active');\n        }\n\n        var image = L.DomUtil.create('img', 'control-icon', newButton);\n        if (button.iconUrl) {\n            image.setAttribute('src', button.iconUrl);\n        }\n        if (button.className) {\n            L.DomUtil.addClass(image, button.className);\n        }\n        // before the actual click, trigger a click on currently toggled buttons to\n        // untoggle them and their functionality\n        L.DomEvent.addListener(newButton, 'click', (e) => {\n            if(this._button.disableOtherButtons) {\n                this._map.pm.Toolbar.triggerClickOnToggledButtons(this);\n            }\n        });\n        L.DomEvent.addListener(newButton, 'click', this._triggerClick, this);\n\n        L.DomEvent.disableClickPropagation(newButton);\n        return newButton;\n\n    },\n\n    _applyStyleClasses: function() {\n\n        if(!this._container) {\n            return;\n        }\n\n        if(!this._button.toggleStatus) {\n            L.DomUtil.removeClass(this.buttonsDomNode,'active');\n        } else {\n            L.DomUtil.addClass(this.buttonsDomNode,'active');\n        }\n    },\n\n    _clicked: function () {\n\n        if(this._button.doToggle){\n            this.toggle();\n        }\n        return;\n    }\n\n});\n","/**\n* The Icons used in this Toolbar are CC-BY Glyphicons - http://glyphicons.com/\n*/\n\nL.PM.Toolbar = L.Class.extend({\n    options: {\n        drawPolygon: true,\n        editPolygon: false,\n        dragPolygon: false,\n        deleteLayer: true\n    },\n    initialize(map) {\n        this.map = map;\n\n        this.buttons = {};\n        this.container = L.DomUtil.create('div', 'leaflet-pm-toolbar leaflet-bar leaflet-control');\n        this._defineButtons();\n    },\n    getButtons: function() {\n        return this.buttons;\n    },\n\n    addControls: function(options = this.options) {\n        // adds all buttons to the map specified inside options\n\n        // first set the options\n        L.Util.setOptions(this, options)\n\n        // now show the specified buttons\n        this._showHideButtons();\n    },\n    _addButton: function(name, button) {\n        this.buttons[name] = button;\n        this.options[name] = this.options[name] || false;\n\n        return this.buttons[name];\n    },\n    triggerClickOnToggledButtons: function(exceptThisButton) {\n        // this function is used when - e.g. drawing mode is enabled and a possible\n        // other active mode (like removal tool) is already active.\n        // we can't have two active modes because of possible event conflicts\n        // so, we trigger a click on all currently active (toggled) buttons\n        for (var name in this.buttons) {\n            if(this.buttons[name] !== exceptThisButton && this.buttons[name].toggled()) {\n                this.buttons[name]._triggerClick();\n            }\n        }\n    },\n    toggleButton: function(name, status) {\n        // does not fire the events/functionality of the button\n        // this just changes the state and is used if a functionality (like Draw)\n        // is enabled manually via script\n\n        // as some mode got enabled, we still have to trigger the click on the other buttons\n        // to disable their mode\n        this.triggerClickOnToggledButtons(this.buttons[name]);\n\n        // now toggle the state of the button\n        return this.buttons[name].toggle(status);\n\n\n    },\n    _defineButtons: function() {\n\n        // some buttons are still in their respective classes, like L.PM.Draw.Poly\n        var deleteButton = {\n            'className': 'icon-delete',\n            'onClick': (e) => {\n\n            },\n            'afterClick': (e) => {\n                this.map.pm.toggleRemoval(this.buttons.deleteLayer.toggled());\n            },\n            'doToggle': true,\n            'toggleStatus': false,\n            'disableOtherButtons': true\n        };\n\n        var drawPolyButton = {\n             'className': 'icon-polygon',\n             'onClick': (e) => {\n\n             },\n             'afterClick': (e) => {\n                 // toggle drawing mode\n                 this.map.pm.Draw.Poly.toggle();\n             },\n             'doToggle': true,\n             'toggleStatus': false,\n             'disableOtherButtons': true\n        };\n\n        var editButton = {\n             'className': 'icon-edit',\n             'onClick': (e) => {\n             },\n             'afterClick': (e) => {\n\n             },\n             'doToggle': true,\n             'toggleStatus': false,\n             'disableOtherButtons': true\n        };\n\n        var dragButton = {\n             'className': 'icon-drag',\n             'onClick': (e) => {\n             },\n             'afterClick': (e) => {\n\n             },\n             'doToggle': true,\n             'toggleStatus': false,\n             'disableOtherButtons': true\n        };\n\n        this._addButton('drawPolygon', new L.Control.PMButton(drawPolyButton));\n        this._addButton('editPolygon', new L.Control.PMButton(editButton));\n        this._addButton('dragPolygon', new L.Control.PMButton(dragButton));\n        this._addButton('deleteLayer', new L.Control.PMButton(deleteButton));\n\n    },\n    _showHideButtons: function() {\n        // loop through all buttons\n        var buttons = this.getButtons();\n\n        for (var btn in buttons) {\n            if(this.options[btn]) {\n                // if options say the button should be visible, add it to the map\n                buttons[btn].addTo(this.map);\n            } else {\n                // if not, remove it\n                buttons[btn].remove();\n            }\n        }\n    }\n});\n"],"sourceRoot":"/source/"}